import{am as vi,an as is,ao as Bn,a9 as Vn,ap as Ye,ai as Qe,d as J,e as I,Y as ce,X as Q,y as ye,aq as Li,ar as Ii,al as Di,M as L,V as b,as as zn,Q as ee,at as Fi,O as Gn,n as Oi,au as Ni,a6 as z,av as ki,K as Hn,aw as Ui,ax as Bi,ay as Vi,L as gt,a3 as jn,p as rs,az as zi,aA as Gi,aB as Wn,a4 as Pt,aC as Hi,aD as qn,_ as ji,m as Le,aE as Wi,a5 as bt,aF as qi,b as ds,aG as Ki,aH as Xi,aI as Zi,aJ as Kn,G as De,a as $i,a8 as v,u as Xn,aK as Yi,aL as Qi,aM as Ji,aN as er,aO as Zn,aP as tr,g as As,aQ as ws,aR as Ss,aS as Es,aT as os,a0 as sr,aU as nr,B as $n,aV as fs,aW as xt,v as Se,aX as Yn,t as ir,w as ps,aY as rr,aZ as Qn,a_ as or,a$ as ar,E as Ze,c as cr,$ as Jn,b0 as lr,C as hr,b1 as ur,h as dr,b2 as Ms,W as fr,k as Cs,b3 as pr,b4 as mr,b5 as gr,b6 as yr,b7 as _r,x as Tr,aj as br}from"./three.module-BQ-k8xsV.js";function Ps(c){if(!c)return null;const e=c.replace(/[a-z]+:\/\/[^/]+/i,"").replace(/\?.*$/i,"").replace(/.*\//g,""),t=e.lastIndexOf(".");return t===-1?null:e.substring(t+1)||null}const Rs=2**30;class ei{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(e){e.length===1?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(t,s)=>{const n=e(t),i=e(s);return n<i?-1:n>i?1:0}):this._unloadPriorityCallback=e}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=.3*Rs,this.maxBytesSize=.4*Rs,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null,this.computeMemoryUsageCallback=()=>null;const e=this.itemSet;this.defaultPriorityCallback=t=>e.get(t)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(e){return this.bytesMap.get(e)??null}add(e,t){const s=this.itemSet;if(s.has(e)||this.isFull())return!1;const n=this.usedSet,i=this.itemList,r=this.callbacks,o=this.bytesMap;i.push(e),n.add(e),s.set(e,Date.now()),r.set(e,t);const a=this.computeMemoryUsageCallback(e);return this.cachedBytes+=a||0,o.set(e,a),!0}has(e){return this.itemSet.has(e)}remove(e){const t=this.usedSet,s=this.itemSet,n=this.itemList,i=this.bytesMap,r=this.callbacks,o=this.loadedSet;if(s.has(e)){this.cachedBytes-=i.get(e)||0,i.delete(e),r.get(e)(e);const a=n.indexOf(e);return n.splice(a,1),t.delete(e),s.delete(e),r.delete(e),o.delete(e),!0}return!1}setLoaded(e,t){const{itemSet:s,loadedSet:n}=this;s.has(e)&&(t===!0?n.add(e):n.delete(e))}updateMemoryUsage(e){const t=this.itemSet,s=this.bytesMap;if(!t.has(e))return;this.cachedBytes-=s.get(e)||0;const n=this.computeMemoryUsageCallback(e);s.set(e,n),this.cachedBytes+=n}markUsed(e){const t=this.itemSet,s=this.usedSet;t.has(e)&&!s.has(e)&&(t.set(e,Date.now()),s.add(e))}markUnused(e){this.usedSet.delete(e)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:e,minSize:t,maxSize:s,itemList:n,itemSet:i,usedSet:r,loadedSet:o,callbacks:a,bytesMap:l,minBytesSize:h,maxBytesSize:u}=this,d=n.length-r.size,f=n.length-o.size,p=Math.max(Math.min(n.length-t,d),0),m=this.cachedBytes-h,g=this.unloadPriorityCallback||this.defaultPriorityCallback;let y=!1;const _=p>0&&d>0||f&&n.length>s;if(d&&this.cachedBytes>h||f&&this.cachedBytes>u||_){n.sort((C,N)=>{const W=r.has(C),Ct=r.has(N);if(W===Ct){const xs=o.has(C),Ri=o.has(N);return xs===Ri?-g(C,N):xs?1:-1}else return W?1:-1});const x=Math.max(t*e,p*e),T=Math.ceil(Math.min(x,d,p)),E=Math.max(e*m,e*h),M=Math.min(E,m);let S=0,w=0;for(;this.cachedBytes-w>u||n.length-S>s;){const C=n[S],N=l.get(C)||0;if(r.has(C)&&o.has(C)||this.cachedBytes-w-N<u&&n.length-S<=s)break;w+=N,S++}for(;w<M||S<T;){const C=n[S],N=l.get(C)||0;if(r.has(C)||this.cachedBytes-w-N<h&&S>=T)break;w+=N,S++}n.splice(0,S).forEach(C=>{this.cachedBytes-=l.get(C)||0,a.get(C)(C),l.delete(C),i.delete(C),a.delete(C),o.delete(C),r.delete(C)}),y=S<p||w<m&&S<d,y=y&&S>0}y&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}}class Rt{constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")},this.schedulingCallback=e=>{requestAnimationFrame(e)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const e=this.priorityCallback;this.items.sort(e)}has(e){return this.callbacks.has(e)}add(e,t){return new Promise((s,n)=>{const i=this.items,r=this.callbacks;i.push(e),r.set(e,{callback:t,resolve:s,reject:n}),this.autoUpdate&&this.scheduleJobRun()})}remove(e){const t=this.items,s=this.callbacks,n=t.indexOf(e);n!==-1&&(t.splice(n,1),s.delete(e))}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,s=this.maxJobs;let n=0;const i=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;s>this.currJobs&&e.length>0&&n<s;){this.currJobs++,n++;const r=e.pop(),{callback:o,resolve:a,reject:l}=t.get(r);t.delete(r);let h;try{h=o(r)}catch(u){l(u),i()}h instanceof Promise?h.then(a).catch(l).finally(i):(a(h),i())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}}const Ie=-1,oe=0,nt=1,vt=2,Je=3,vs=6378137,xr=6356752314245179e-9,it={inView:!1,error:1/0,distance:1/0};function ti(c){return c===Je||c===Ie}function _e(c,e){return c.__lastFrameVisited===e&&c.__used}function ms(c){return c.__childrenProcessed===c.children.length}function gs(c,e){c.__lastFrameVisited!==e.frameCount&&(c.__lastFrameVisited=e.frameCount,c.__used=!1,c.__inFrustum=!1,c.__isLeaf=!1,c.__visible=!1,c.__active=!1,c.__error=1/0,c.__distanceFromCamera=1/0,c.__childrenWereVisible=!1,c.__allChildrenLoaded=!1,e.calculateTileViewError(c,it),c.__inFrustum=it.inView,c.__error=it.error,c.__distanceFromCamera=it.distance)}function si(c,e){if(e.ensureChildrenArePreprocessed(c),gs(c,e),as(c,e),!c.__hasRenderableContent&&ms(c)){const t=c.children;for(let s=0,n=t.length;s<n;s++)si(t[s],e)}}function ni(c,e){if(e.ensureChildrenArePreprocessed(c),_e(c,e.frameCount)&&(c.__hasContent&&c.__loadingState===oe&&!e.lruCache.isFull()&&e.queueTileForDownload(c),ms(c))){const t=c.children;for(let s=0,n=t.length;s<n;s++)ni(t[s],e)}}function as(c,e){c.__used||(c.__used=!0,e.markTileUsed(c),e.stats.used++,c.__inFrustum===!0&&e.stats.inFrustum++)}function Ar(c,e){return!(c.__error<=e.errorTarget||e.maxDepth>0&&c.__depth+1>=e.maxDepth||!ms(c))}function ii(c,e=null,t=null){const s=[];for(s.push(c),s.push(null),s.push(0);s.length>0;){const n=s.pop(),i=s.pop(),r=s.pop();if(e&&e(r,i,n)){t&&t(r,i,n);return}const o=r.children;if(o)for(let a=o.length-1;a>=0;a--)s.push(o[a]),s.push(r),s.push(n+1);t&&t(r,i,n)}}function ri(c,e){if(e.ensureChildrenArePreprocessed(c),gs(c,e),!c.__inFrustum)return;if(!Ar(c,e)){as(c,e);return}let t=!1,s=!1;const n=c.children;for(let i=0,r=n.length;i<r;i++){const o=n[i];ri(o,e),t=t||_e(o,e.frameCount),s=s||o.__inFrustum}if(c.refine==="REPLACE"&&!s&&n.length!==0&&!c.__hasUnrenderableContent){c.__inFrustum=!1;return}if(as(c,e),t&&c.refine==="REPLACE")for(let i=0,r=n.length;i<r;i++){const o=n[i];si(o,e)}}function oi(c,e){const t=e.frameCount;if(!_e(c,t))return;const s=c.children;let n=!1;for(let i=0,r=s.length;i<r;i++){const o=s[i];n=n||_e(o,t)}if(!n)c.__isLeaf=!0;else{let i=!1,r=!0;for(let o=0,a=s.length;o<a;o++){const l=s[o];if(oi(l,e),i=i||l.__wasSetVisible||l.__childrenWereVisible,_e(l,t)){const h=l.__allChildrenLoaded||l.__hasRenderableContent&&ti(l.__loadingState)||!l.__hasContent&&l.children.length===0||l.__hasUnrenderableContent&&l.__loadingState===Ie;r=r&&h}}c.__childrenWereVisible=i,c.__allChildrenLoaded=r}}function ai(c,e){const t=e.stats;if(!_e(c,e.frameCount))return;const s=e.lruCache;if(c.__isLeaf){c.__loadingState===Je?(c.__inFrustum&&(c.__visible=!0,t.visible++),c.__active=!0,t.active++):!s.isFull()&&c.__hasContent&&e.queueTileForDownload(c);return}const n=c.children,i=c.__hasContent,r=ti(c.__loadingState)&&i,o=(e.errorTarget+1)*e.errorThreshold,a=c.__error<=o,l=c.__childrenWereVisible,h=c.__allChildrenLoaded;if((a||c.refine==="ADD")&&!r&&!s.isFull()&&i&&e.queueTileForDownload(c),(a&&!h&&!l&&r||c.refine==="ADD"&&r)&&(c.__inFrustum&&(c.__visible=!0,t.visible++),c.__active=!0,t.active++),c.refine==="REPLACE"&&a&&!h)for(let d=0,f=n.length;d<f;d++){const p=n[d];_e(p,e.frameCount)&&ni(p,e)}else for(let d=0,f=n.length;d<f;d++)ai(n[d],e)}function ci(c,e){const t=_e(c,e.frameCount);if(t||c.__usedLastFrame){let s=!1,n=!1;t?(s=c.__active,e.displayActiveTiles?n=c.__active||c.__visible:n=c.__visible):gs(c,e),c.__hasRenderableContent&&c.__loadingState===Je&&(c.__wasSetActive!==s&&e.invokeOnePlugin(r=>r.setTileActive&&r.setTileActive(c,s)),c.__wasSetVisible!==n&&e.invokeOnePlugin(r=>r.setTileVisible&&r.setTileVisible(c,n))),c.__wasSetActive=s,c.__wasSetVisible=n,c.__usedLastFrame=t;const i=c.children;for(let r=0,o=i.length;r<o;r++){const a=i[r];ci(a,e)}}}const Ls=Symbol("PLUGIN_REGISTERED"),Lt=(c,e)=>c.__depthFromRenderedParent!==e.__depthFromRenderedParent?c.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:c.__inFrustum!==e.__inFrustum?c.__inFrustum?1:-1:c.__used!==e.__used?c.__used?1:-1:c.__error!==e.__error?c.__error>e.__error?1:-1:c.__distanceFromCamera!==e.__distanceFromCamera?c.__distanceFromCamera>e.__distanceFromCamera?-1:1:0,wr=(c,e)=>c.__depthFromRenderedParent!==e.__depthFromRenderedParent?c.__depthFromRenderedParent>e.__depthFromRenderedParent?1:-1:c.__loadingState!==e.__loadingState?c.__loadingState>e.__loadingState?-1:1:c.__lastFrameVisited!==e.__lastFrameVisited?c.__lastFrameVisited>e.__lastFrameVisited?-1:1:c.__hasUnrenderableContent!==e.__hasUnrenderableContent?c.__hasUnrenderableContent?-1:1:c.__error!==e.__error?c.__error>e.__error?-1:1:0;class Sr{get root(){const e=this.rootTileSet;return e?e.root:null}get loadProgress(){const e=this.stats,t=e.downloading+e.parsing,s=e.inCacheSinceLoad;return s===0?1:1-t/s}get errorThreshold(){return this._errorThreshold}set errorThreshold(e){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=e}constructor(e=null){this.rootLoadingState=oe,this.rootTileSet=null,this.rootURL=e,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set;const t=new ei;t.unloadPriorityCallback=wr;const s=new Rt;s.maxJobs=10,s.priorityCallback=Lt;const n=new Rt;n.maxJobs=1,n.priorityCallback=Lt;const i=new Rt;i.maxJobs=25,i.priorityCallback=Lt,i.log=!0,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=t,this.downloadQueue=s,this.parseQueue=n,this.processNodeQueue=i,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this.errorTarget=6,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(e){if(e[Ls]===!0)throw new Error("TilesRendererBase: A plugin can only be registered to a single tile set");const t=this.plugins,s=e.priority||0;let n=t.length;for(let i=0;i<t.length;i++)if((t[i].priority||0)>s){n=i;break}t.splice(n,0,e),e[Ls]=!0,e.init&&e.init(this)}unregisterPlugin(e){const t=this.plugins;if(typeof e=="string"&&(e=this.getPluginByName(name)),t.includes(e)){const s=t.indexOf(e);return t.splice(s,1),e.dispose&&e.dispose(),!0}return!1}getPluginByName(e){return this.plugins.find(t=>t.name===e)||null}traverse(e,t,s=!0){this.root&&ii(this.root,(n,...i)=>(s&&this.ensureChildrenArePreprocessed(n,!0),e?e(n,...i):!1),t)}queueTileForDownload(e){e.__loadingState===oe&&this.queuedTiles.push(e)}markTileUsed(e){this.usedSet.add(e),this.lruCache.markUsed(e)}update(){const{lruCache:e,usedSet:t,stats:s,root:n}=this;if(this.rootLoadingState===oe&&(this.rootLoadingState=nt,this.invokeOnePlugin(r=>r.loadRootTileSet&&r.loadRootTileSet()).then(r=>{this.rootLoadingState=Je,this.rootTileSet=r,this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:r})}).catch(r=>{this.rootLoadingState=Ie,console.error(r),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:r})})),!n)return;s.inFrustum=0,s.used=0,s.active=0,s.visible=0,this.frameCount++,t.forEach(r=>e.markUnused(r)),t.clear(),ri(n,this),oi(n,this),ai(n,this),ci(n,this);const i=this.queuedTiles;i.sort(e.unloadPriorityCallback);for(let r=0,o=i.length;r<o&&!e.isFull();r++)this.requestTileContents(i[r]);i.length=0,e.scheduleUnload()}resetFailedTiles(){this.rootLoadingState===Ie&&(this.rootLoadingState=oe);const e=this.stats;e.failed!==0&&(this.traverse(t=>{t.__loadingState===Ie&&(t.__loadingState=oe)},null,!1),e.failed=0)}dispose(){this.plugins.forEach(s=>{this.unregisterPlugin(s)});const e=this.lruCache,t=[];this.traverse(s=>(t.push(s),!1),null,!1);for(let s=0,n=t.length;s<n;s++)e.remove(t[s]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}dispatchEvent(e){}fetchData(e,t){return fetch(e,t)}parseTile(e,t,s){return null}disposeTile(e){e.__visible&&(this.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,!1)),e.__visible=!1),e.__active&&(this.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,!1)),e.__active=!1)}preprocessNode(e,t,s=null){var n;if(e.content&&(!("uri"in e.content)&&"url"in e.content&&(e.content.uri=e.content.url,delete e.content.url),e.content.boundingVolume&&!("box"in e.content.boundingVolume||"sphere"in e.content.boundingVolume||"region"in e.content.boundingVolume)&&delete e.content.boundingVolume),e.parent=s,e.children=e.children||[],(n=e.content)!=null&&n.uri){const i=Ps(e.content.uri);e.__hasContent=!0,e.__hasUnrenderableContent=!!(i&&/json$/.test(i)),e.__hasRenderableContent=!e.__hasUnrenderableContent}else e.__hasContent=!1,e.__hasUnrenderableContent=!1,e.__hasRenderableContent=!1;e.__childrenProcessed=0,s&&s.__childrenProcessed++,e.__distanceFromCamera=1/0,e.__error=1/0,e.__inFrustum=!1,e.__isLeaf=!1,e.__usedLastFrame=!1,e.__used=!1,e.__wasSetVisible=!1,e.__visible=!1,e.__childrenWereVisible=!1,e.__allChildrenLoaded=!1,e.__wasSetActive=!1,e.__active=!1,e.__loadingState=oe,s===null?(e.__depth=0,e.__depthFromRenderedParent=e.__hasRenderableContent?1:0,e.refine=e.refine||"REPLACE"):(e.__depth=s.__depth+1,e.__depthFromRenderedParent=s.__depthFromRenderedParent+(e.__hasRenderableContent?1:0),e.refine=e.refine||s.refine),e.__basePath=t,e.__lastFrameVisited=-1,this.invokeAllPlugins(i=>{i!==this&&i.preprocessNode&&i.preprocessNode(e,t,s)})}setTileActive(e,t){t?this.activeTiles.add(e):this.activeTiles.delete(e)}setTileVisible(e,t){t?this.visibleTiles.add(e):this.visibleTiles.delete(e)}calculateTileViewError(e,t){}ensureChildrenArePreprocessed(e,t=!1){const s=e.children;for(let n=0,i=s.length;n<i;n++){const r=s[n];if("__depth"in r)break;t?(this.processNodeQueue.remove(r),this.preprocessNode(r,e.__basePath,e)):this.processNodeQueue.has(r)||this.processNodeQueue.add(r,o=>{this.preprocessNode(o,e.__basePath,e)})}}preprocessTileSet(e,t,s=null){const n=e.asset.version,[i,r]=n.split(".").map(a=>parseInt(a));console.assert(i<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),i===1&&r>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let o=t.replace(/\/[^/]*\/?$/,"");o=new URL(o,window.location.href).toString(),this.preprocessNode(e.root,o,s)}loadRootTileSet(){let e=this.rootURL;return this.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),this.invokeOnePlugin(s=>s.fetchData&&s.fetchData(e,this.fetchOptions)).then(s=>{if(s.ok)return s.json();throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${s.status} : ${s.statusText}`)}).then(s=>(this.preprocessTileSet(s,e),s))}requestTileContents(e){if(e.__loadingState!==oe)return;let t=!1,s=new URL(e.content.uri,e.__basePath+"/").toString();this.invokeAllPlugins(d=>s=d.preprocessURL?d.preprocessURL(s,e):s);const n=this.stats,i=this.lruCache,r=this.downloadQueue,o=this.parseQueue,a=Ps(s),l=new AbortController,h=l.signal;if(i.add(e,d=>{l.abort(),t?(d.children.length=0,d.__childrenProcessed=0):this.invokeAllPlugins(f=>{f.disposeTile&&f.disposeTile(d)}),n.inCache--,this.cachedSinceLoadComplete.has(e)&&(this.cachedSinceLoadComplete.delete(e),n.inCacheSinceLoad--),d.__loadingState===nt?n.downloading--:d.__loadingState===vt&&n.parsing--,d.__loadingState=oe,o.remove(d),r.remove(d)}))return n.parsing===0&&n.downloading===0&&this.dispatchEvent({type:"tiles-load-start"}),this.cachedSinceLoadComplete.add(e),n.inCacheSinceLoad++,n.inCache++,n.downloading++,e.__loadingState=nt,r.add(e,d=>h.aborted?Promise.resolve():this.invokeOnePlugin(f=>f.fetchData&&f.fetchData(s,{...this.fetchOptions,signal:h}))).then(d=>{if(!h.aborted){if(d.ok)return a==="json"?d.json():d.arrayBuffer();throw new Error(`Failed to load model with error code ${d.status}`)}}).then(d=>{if(!h.aborted)return n.downloading--,n.parsing++,e.__loadingState=vt,o.add(e,f=>h.aborted?Promise.resolve():a==="json"&&d.root?(this.preprocessTileSet(d,s,e),e.children.push(d.root),t=!0,Promise.resolve()):this.invokeOnePlugin(p=>p.parseTile&&p.parseTile(d,f,a,s,h)))}).then(()=>{h.aborted||(n.parsing--,e.__loadingState=Je,i.setLoaded(e,!0),i.getMemoryUsage(e)===null&&(i.isFull()&&i.computeMemoryUsageCallback(e)>0?i.remove(e):i.updateMemoryUsage(e)),this.dispatchEvent({type:"load-content"}),e.cached.scene&&this.dispatchEvent({type:"load-model",scene:e.cached.scene,tile:e}))}).catch(d=>{h.aborted||(d.name!=="AbortError"?(o.remove(e),r.remove(e),e.__loadingState===vt?n.parsing--:e.__loadingState===nt&&n.downloading--,n.failed++,console.error(`TilesRenderer : Failed to load tile at url "${e.content.uri}".`),console.error(d),e.__loadingState=Ie,i.setLoaded(e,!0),this.dispatchEvent({type:"load-error",tile:e,error:d,uri:s})):i.remove(e))}).finally(()=>{n.parsing===0&&n.downloading===0&&(this.cachedSinceLoadComplete.clear(),n.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}))})}getAttributions(e=[]){return this.invokeAllPlugins(t=>t!==this&&t.getAttributions&&t.getAttributions(e)),e}invokeOnePlugin(e){const t=[...this.plugins,this];for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}invokeAllPlugins(e){const t=[...this.plugins,this],s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s.length===0?null:Promise.all(s)}}const Er=new TextDecoder;function li(c){return Er.decode(c)}function hi(c,e,t,s,n,i){let r;switch(s){case"SCALAR":r=1;break;case"VEC2":r=2;break;case"VEC3":r=3;break;case"VEC4":r=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${i}".`)}let o;const a=t*r;switch(n){case"BYTE":o=new Int8Array(c,e,a);break;case"UNSIGNED_BYTE":o=new Uint8Array(c,e,a);break;case"SHORT":o=new Int16Array(c,e,a);break;case"UNSIGNED_SHORT":o=new Uint16Array(c,e,a);break;case"INT":o=new Int32Array(c,e,a);break;case"UNSIGNED_INT":o=new Uint32Array(c,e,a);break;case"FLOAT":o=new Float32Array(c,e,a);break;case"DOUBLE":o=new Float64Array(c,e,a);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${i}".`)}return o}class At{constructor(e,t,s,n){this.buffer=e,this.binOffset=t+s,this.binLength=n;let i=null;if(s!==0){const r=new Uint8Array(e,t,s);i=JSON.parse(li(r))}else i={};this.header=i}getKeys(){return Object.keys(this.header)}getData(e,t,s=null,n=null){const i=this.header;if(!(e in i))return null;const r=i[e];if(r instanceof Object){if(Array.isArray(r))return r;{const{buffer:o,binOffset:a,binLength:l}=this,h=r.byteOffset||0,u=r.type||n,d=r.componentType||s;if("type"in r&&n&&r.type!==n)throw new Error("FeatureTable: Specified type does not match expected type.");const f=a+h,p=hi(o,f,t,u,d,e);if(f+p.byteLength>a+l)throw new Error("FeatureTable: Feature data read outside binary body length.");return p}}else return r}getBuffer(e,t){const{buffer:s,binOffset:n}=this;return s.slice(n+e,n+e+t)}}class Mr{constructor(e){this.batchTable=e;const t=e.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=t.classes;for(const n of this.classes){const i=n.instances;for(const r in i)n.instances[r]=this._parseProperty(i[r],n.length,r)}if(this.instancesLength=t.instancesLength,this.classIds=this._parseProperty(t.classIds,this.instancesLength,"classIds"),t.parentCounts?this.parentCounts=this._parseProperty(t.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),t.parentIds){const n=this.parentCounts.reduce((i,r)=>i+r,0);this.parentIds=this._parseProperty(t.parentIds,n,"parentIds")}else this.parentIds=null;this.instancesIds=[];const s={};for(const n of this.classIds)s[n]=s[n]??0,this.instancesIds.push(s[n]),s[n]++}_parseProperty(e,t,s){if(Array.isArray(e))return e;{const{buffer:n,binOffset:i}=this.batchTable,r=e.byteOffset,o=e.componentType||"UNSIGNED_SHORT",a=i+r;return hi(n,a,t,"SCALAR",o,s)}}getDataFromId(e,t={}){const s=this.parentCounts[e];if(this.parentIds&&s>0){let a=0;for(let l=0;l<e;l++)a+=this.parentCounts[l];for(let l=0;l<s;l++){const h=this.parentIds[a+l];h!==e&&this.getDataFromId(h,t)}}const n=this.classIds[e],i=this.classes[n].instances,r=this.classes[n].name,o=this.instancesIds[e];for(const a in i)t[r]=t[r]||{},t[r][a]=i[a][o];return t}}class ys extends At{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(e,t,s,n,i){super(e,s,n,i),this.count=t,this.extensions={};const r=this.header.extensions;r&&r["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new Mr(this))}getData(e,t=null,s=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(e,this.count,t,s)}getDataFromId(e,t={}){if(e<0||e>=this.count)throw new Error(`BatchTable: id value "${e}" out of bounds for "${this.count}" features number.`);for(const s of this.getKeys())s!=="extensions"&&(t[s]=super.getData(s,this.count)[e]);for(const s in this.extensions){const n=this.extensions[s];n.getDataFromId instanceof Function&&(t[s]=t[s]||{},n.getDataFromId(e,t[s]))}return t}getPropertyArray(e){return super.getData(e,this.count)}}class wt{constructor(){this.fetchOptions={},this.workingPath=""}load(e){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(e)}loadAsync(e){return fetch(e,this.fetchOptions).then(t=>{if(!t.ok)throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()}).then(t=>(this.workingPath===""&&(this.workingPath=this.workingPathForURL(e)),this.parse(t)))}resolveExternalURL(e){return/^[^\\/]/.test(e)&&!/^http/.test(e)?this.workingPath+"/"+e:e}workingPathForURL(e){const t=e.split(/[\\/]/g);return t.pop(),t.join("/")+"/"}parse(e){throw new Error("LoaderBase: Parse not implemented.")}}function Oe(c){let e;if(c instanceof DataView?e=c:e=new DataView(c),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let s=0;s<4;s++)t+=String.fromCharCode(e.getUint8(s));return t}class Cr extends wt{parse(e){const t=new DataView(e),s=Oe(t);console.assert(s==="b3dm");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),o=t.getUint32(16,!0),a=t.getUint32(20,!0),l=t.getUint32(24,!0),h=28,u=e.slice(h,h+r+o),d=new At(u,0,r,o),f=h+r+o,p=e.slice(f,f+a+l),m=new ys(p,d.getData("BATCH_LENGTH"),0,a,l),g=f+a+l,y=new Uint8Array(e,g,i-g);return{version:n,featureTable:d,batchTable:m,glbBytes:y}}}function Pr(c){let e=0;for(const s in c.attributes){const n=c.getAttribute(s);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const t=c.getIndex();return e+=t?t.count*t.itemSize*t.array.BYTES_PER_ELEMENT:0,e}function Is(c,e){if(e===vi)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),c;if(e===is||e===Bn){let t=c.getIndex();if(t===null){const r=[],o=c.getAttribute("position");if(o!==void 0){for(let a=0;a<o.count;a++)r.push(a);c.setIndex(r),t=c.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),c}const s=t.count-2,n=[];if(e===is)for(let r=1;r<=s;r++)n.push(t.getX(0)),n.push(t.getX(r)),n.push(t.getX(r+1));else for(let r=0;r<s;r++)r%2===0?(n.push(t.getX(r)),n.push(t.getX(r+1)),n.push(t.getX(r+2))):(n.push(t.getX(r+2)),n.push(t.getX(r+1)),n.push(t.getX(r)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=c.clone();return i.setIndex(n),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),c}class St extends Vn{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Dr(t)}),this.register(function(t){return new Fr(t)}),this.register(function(t){return new Hr(t)}),this.register(function(t){return new jr(t)}),this.register(function(t){return new Wr(t)}),this.register(function(t){return new Nr(t)}),this.register(function(t){return new kr(t)}),this.register(function(t){return new Ur(t)}),this.register(function(t){return new Br(t)}),this.register(function(t){return new Ir(t)}),this.register(function(t){return new Vr(t)}),this.register(function(t){return new Or(t)}),this.register(function(t){return new Gr(t)}),this.register(function(t){return new zr(t)}),this.register(function(t){return new vr(t)}),this.register(function(t){return new qr(t)}),this.register(function(t){return new Kr(t)})}load(e,t,s,n){const i=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const l=Ye.extractUrlBase(e);r=Ye.resolveURL(l,this.path)}else r=Ye.extractUrlBase(e);this.manager.itemStart(e);const o=function(l){n?n(l):console.error(l),i.manager.itemError(e),i.manager.itemEnd(e)},a=new Qe(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{i.parse(l,r,function(h){t(h),i.manager.itemEnd(e)},o)}catch(h){o(h)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let i;const r={},o={},a=new TextDecoder;if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(a.decode(new Uint8Array(e,0,4))===ui){try{r[P.KHR_BINARY_GLTF]=new Xr(e)}catch(u){n&&n(u);return}i=JSON.parse(r[P.KHR_BINARY_GLTF].content)}else i=JSON.parse(a.decode(e));else i=e;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new ao(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const u=this.pluginCallbacks[h](l);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[u.name]=u,r[u.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const u=i.extensionsUsed[h],d=i.extensionsRequired||[];switch(u){case P.KHR_MATERIALS_UNLIT:r[u]=new Lr;break;case P.KHR_DRACO_MESH_COMPRESSION:r[u]=new Zr(i,this.dracoLoader);break;case P.KHR_TEXTURE_TRANSFORM:r[u]=new $r;break;case P.KHR_MESH_QUANTIZATION:r[u]=new Yr;break;default:d.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}l.setExtensions(r),l.setPlugins(o),l.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,i){s.parse(e,t,n,i)})}}function Rr(){let c={};return{get:function(e){return c[e]},add:function(e,t){c[e]=t},remove:function(e){delete c[e]},removeAll:function(){c={}}}}const P={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class vr{constructor(e){this.parser=e,this.name=P.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const i=t.json,a=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let l;const h=new ce(16777215);a.color!==void 0&&h.setRGB(a.color[0],a.color[1],a.color[2],Q);const u=a.range!==void 0?a.range:0;switch(a.type){case"directional":l=new Di(h),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new Ii(h),l.distance=u;break;case"spot":l=new Li(h),l.distance=u,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,l.angle=a.spot.outerConeAngle,l.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return l.position.set(0,0,0),ae(l,a),a.intensity!==void 0&&(l.intensity=a.intensity),l.name=t.createUniqueName(a.name||"light_"+e),n=Promise.resolve(l),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(a){return s._getNodeRef(t.cache,o,a)})}}class Lr{constructor(){this.name=P.KHR_MATERIALS_UNLIT}getMaterialType(){return Le}extendParams(e,t,s){const n=[];e.color=new ce(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const r=i.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],Q),e.opacity=r[3]}i.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",i.baseColorTexture,ye))}return Promise.all(n)}}class Ir{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class Dr{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const o=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new I(o,o)}return Promise.all(i)}}class Fr{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}}class Or{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}}class Nr{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new ce(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=n.extensions[this.name];if(r.sheenColorFactor!==void 0){const o=r.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],Q)}return r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,ye)),r.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}}class kr{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}}class Ur{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const o=r.attenuationColor||[1,1,1];return t.attenuationColor=new ce().setRGB(o[0],o[1],o[2],Q),Promise.all(i)}}class Br{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class Vr{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const o=r.specularColorFactor||[1,1,1];return t.specularColor=new ce().setRGB(o[0],o[1],o[2],Q),r.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,ye)),Promise.all(i)}}class zr{constructor(e){this.parser=e,this.name=P.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&i.push(s.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(i)}}class Gr{constructor(e){this.parser=e,this.name=P.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:J}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&i.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(i)}}class Hr{constructor(e){this.parser=e,this.name=P.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}}class jr{constructor(e){this.parser=e,this.name=P.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],o=n.images[r.source];let a=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(a=l)}return this.detectSupport().then(function(l){if(l)return s.loadTextureImage(e,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Wr{constructor(e){this.parser=e,this.name=P.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],o=n.images[r.source];let a=s.textureLoader;if(o.uri){const l=s.options.manager.getHandler(o.uri);l!==null&&(a=l)}return this.detectSupport().then(function(l){if(l)return s.loadTextureImage(e,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class qr{constructor(e){this.name=P.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(o){const a=n.byteOffset||0,l=n.byteLength||0,h=n.count,u=n.byteStride,d=new Uint8Array(o,a,l);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,u,d,n.mode,n.filter).then(function(f){return f.buffer}):r.ready.then(function(){const f=new ArrayBuffer(h*u);return r.decodeGltfBuffer(new Uint8Array(f),h,u,d,n.mode,n.filter),f})})}else return null}}class Kr{constructor(e){this.name=P.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const l of n.primitives)if(l.mode!==X.TRIANGLES&&l.mode!==X.TRIANGLE_STRIP&&l.mode!==X.TRIANGLE_FAN&&l.mode!==void 0)return null;const r=s.extensions[this.name].attributes,o=[],a={};for(const l in r)o.push(this.parser.getDependency("accessor",r[l]).then(h=>(a[l]=h,a[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const h=l.pop(),u=h.isGroup?h.children:[h],d=l[0].count,f=[];for(const p of u){const m=new L,g=new b,y=new ee,_=new b(1,1,1),A=new zn(p.geometry,p.material,d);for(let x=0;x<d;x++)a.TRANSLATION&&g.fromBufferAttribute(a.TRANSLATION,x),a.ROTATION&&y.fromBufferAttribute(a.ROTATION,x),a.SCALE&&_.fromBufferAttribute(a.SCALE,x),A.setMatrixAt(x,m.compose(g,y,_));for(const x in a)if(x==="_COLOR_0"){const T=a[x];A.instanceColor=new Fi(T.array,T.itemSize,T.normalized)}else x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&p.geometry.setAttribute(x,a[x]);Gn.prototype.copy.call(A,p),this.parser.assignFinalMaterial(A),f.push(A)}return h.isGroup?(h.clear(),h.add(...f),h):f[0]}))}}const ui="glTF",Ne=12,Ds={JSON:1313821514,BIN:5130562};class Xr{constructor(e){this.name=P.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Ne),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==ui)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Ne,i=new DataView(e,Ne);let r=0;for(;r<n;){const o=i.getUint32(r,!0);r+=4;const a=i.getUint32(r,!0);if(r+=4,a===Ds.JSON){const l=new Uint8Array(e,Ne+r,o);this.content=s.decode(l)}else if(a===Ds.BIN){const l=Ne+r;this.body=e.slice(l,l+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Zr{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=P.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,o={},a={},l={};for(const h in r){const u=cs[h]||h.toLowerCase();o[u]=r[h]}for(const h in e.attributes){const u=cs[h]||h.toLowerCase();if(r[h]!==void 0){const d=s.accessors[e.attributes[h]],f=Fe[d.componentType];l[u]=f.name,a[u]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(u,d){n.decodeDracoFile(h,function(f){for(const p in f.attributes){const m=f.attributes[p],g=a[p];g!==void 0&&(m.normalized=g)}u(f)},o,l,Q,d)})})}}class $r{constructor(){this.name=P.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Yr{constructor(){this.name=P.KHR_MESH_QUANTIZATION}}class di extends nr{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,i=e*n*3+n;for(let r=0;r!==n;r++)t[r]=s[i+r];return t}interpolate_(e,t,s,n){const i=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=o*2,l=o*3,h=n-t,u=(s-t)/h,d=u*u,f=d*u,p=e*l,m=p-l,g=-2*f+3*d,y=f-d,_=1-g,A=y-d+u;for(let x=0;x!==o;x++){const T=r[m+x+o],E=r[m+x+a]*h,M=r[p+x+o],S=r[p+x]*h;i[x]=_*T+A*E+g*M+y*S}return i}}const Qr=new ee;class Jr extends di{interpolate_(e,t,s,n){const i=super.interpolate_(e,t,s,n);return Qr.fromArray(i).normalize().toArray(i),i}}const X={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Fe={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Fs={9728:jn,9729:gt,9984:Vi,9985:Bi,9986:Ui,9987:Hn},Os={33071:Gi,33648:zi,10497:rs},It={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},cs={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},le={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},eo={CUBICSPLINE:void 0,LINEAR:Zn,STEP:er},Dt={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function to(c){return c.DefaultMaterial===void 0&&(c.DefaultMaterial=new qn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:sr})),c.DefaultMaterial}function Te(c,e,t){for(const s in t.extensions)c[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function ae(c,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(c.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function so(c,e,t){let s=!1,n=!1,i=!1;for(let l=0,h=e.length;l<h;l++){const u=e[l];if(u.POSITION!==void 0&&(s=!0),u.NORMAL!==void 0&&(n=!0),u.COLOR_0!==void 0&&(i=!0),s&&n&&i)break}if(!s&&!n&&!i)return Promise.resolve(c);const r=[],o=[],a=[];for(let l=0,h=e.length;l<h;l++){const u=e[l];if(s){const d=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):c.attributes.position;r.push(d)}if(n){const d=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):c.attributes.normal;o.push(d)}if(i){const d=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):c.attributes.color;a.push(d)}}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(a)]).then(function(l){const h=l[0],u=l[1],d=l[2];return s&&(c.morphAttributes.position=h),n&&(c.morphAttributes.normal=u),i&&(c.morphAttributes.color=d),c.morphTargetsRelative=!0,c})}function no(c,e){if(c.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)c.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(c.morphTargetInfluences.length===t.length){c.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)c.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function io(c){let e;const t=c.extensions&&c.extensions[P.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Ft(t.attributes):e=c.indices+":"+Ft(c.attributes)+":"+c.mode,c.targets!==void 0)for(let s=0,n=c.targets.length;s<n;s++)e+=":"+Ft(c.targets[s]);return e}function Ft(c){let e="";const t=Object.keys(c).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+c[t[s]]+";";return e}function ls(c){switch(c){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function ro(c){return c.search(/\.jpe?g($|\?)/i)>0||c.search(/^data\:image\/jpeg/)===0?"image/jpeg":c.search(/\.webp($|\?)/i)>0||c.search(/^data\:image\/webp/)===0?"image/webp":c.search(/\.ktx2($|\?)/i)>0||c.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const oo=new L;class ao{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Rr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,i=!1,r=-1;if(typeof navigator<"u"){const o=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(o)===!0;const a=o.match(/Version\/(\d+)/);n=s&&a?parseInt(a[1],10):-1,i=o.indexOf("Firefox")>-1,r=i?o.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||i&&r<98?this.textureLoader=new Oi(this.options.manager):this.textureLoader=new Ni(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Qe(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(r){const o={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:s,userData:{}};return Te(i,o,n),ae(o,n),Promise.all(s._invokeAll(function(a){return a.afterRoot&&a.afterRoot(o)})).then(function(){for(const a of o.scenes)a.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n].joints;for(let o=0,a=r.length;o<a;o++)e[r[o]].isBone=!0}for(let n=0,i=e.length;n<i;n++){const r=e[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(s[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),i=(r,o)=>{const a=this.associations.get(r);a!=null&&this.associations.set(o,a);for(const[l,h]of r.children.entries())i(h,o.children[l])};return i(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,r){return s.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[P.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,r){s.load(Ye.resolveURL(t.uri,n.path),i,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const r=It[n.type],o=Fe[n.componentType],a=n.normalized===!0,l=new o(n.count*r);return Promise.resolve(new z(l,r,a))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(r){const o=r[0],a=It[n.type],l=Fe[n.componentType],h=l.BYTES_PER_ELEMENT,u=h*a,d=n.byteOffset||0,f=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,p=n.normalized===!0;let m,g;if(f&&f!==u){const y=Math.floor(d/f),_="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+y+":"+n.count;let A=t.cache.get(_);A||(m=new l(o,y*f,n.count*f/h),A=new ki(m,f/h),t.cache.add(_,A)),g=new tr(A,a,d%f/h,p)}else o===null?m=new l(n.count*a):m=new l(o,d,n.count*a),g=new z(m,a,p);if(n.sparse!==void 0){const y=It.SCALAR,_=Fe[n.sparse.indices.componentType],A=n.sparse.indices.byteOffset||0,x=n.sparse.values.byteOffset||0,T=new _(r[1],A,n.sparse.count*y),E=new l(r[2],x,n.sparse.count*a);o!==null&&(g=new z(g.array.slice(),g.itemSize,g.normalized)),g.normalized=!1;for(let M=0,S=T.length;M<S;M++){const w=T[M];if(g.setX(w,E[M*a]),a>=2&&g.setY(w,E[M*a+1]),a>=3&&g.setZ(w,E[M*a+2]),a>=4&&g.setW(w,E[M*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}g.normalized=p}return g})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,r=t.images[i];let o=this.textureLoader;if(r.uri){const a=s.manager.getHandler(r.uri);a!==null&&(o=a)}return this.loadTextureImage(e,i,o)}loadTextureImage(e,t,s){const n=this,i=this.json,r=i.textures[e],o=i.images[t],a=(o.uri||o.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const l=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=r.name||o.name||"",h.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(h.name=o.uri);const d=(i.samplers||{})[r.sampler]||{};return h.magFilter=Fs[d.magFilter]||gt,h.minFilter=Fs[d.minFilter]||Hn,h.wrapS=Os[d.wrapS]||rs,h.wrapT=Os[d.wrapT]||rs,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==jn&&h.minFilter!==gt,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[a]=l,l}loadImageSource(e,t){const s=this,n=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const r=n.images[e],o=self.URL||self.webkitURL;let a=r.uri||"",l=!1;if(r.bufferView!==void 0)a=s.getDependency("bufferView",r.bufferView).then(function(u){l=!0;const d=new Blob([u],{type:r.mimeType});return a=o.createObjectURL(d),a});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(a).then(function(u){return new Promise(function(d,f){let p=d;t.isImageBitmapLoader===!0&&(p=function(m){const g=new As(m);g.needsUpdate=!0,d(g)}),t.load(Ye.resolveURL(u,i.path),p,void 0,f)})}).then(function(u){return l===!0&&o.revokeObjectURL(a),ae(u,r),u.userData.mimeType=r.mimeType||ro(r.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),u});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const i=this;return this.getDependency("texture",s.index).then(function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(r=r.clone(),r.channel=s.texCoord),i.extensions[P.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[P.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const a=i.associations.get(r);r=i.extensions[P.KHR_TEXTURE_TRANSFORM].extendTexture(r,o),i.associations.set(r,a)}}return n!==void 0&&(r.colorSpace=n),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let a=this.cache.get(o);a||(a=new Wn,Pt.prototype.copy.call(a,s),a.color.copy(s.color),a.map=s.map,a.sizeAttenuation=!1,this.cache.add(o,a)),s=a}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let a=this.cache.get(o);a||(a=new Hi,Pt.prototype.copy.call(a,s),a.color.copy(s.color),a.map=s.map,this.cache.add(o,a)),s=a}if(n||i||r){let o="ClonedMaterial:"+s.uuid+":";n&&(o+="derivative-tangents:"),i&&(o+="vertex-colors:"),r&&(o+="flat-shading:");let a=this.cache.get(o);a||(a=s.clone(),i&&(a.vertexColors=!0),r&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(o,a),this.associations.set(a,this.associations.get(s))),s=a}e.material=s}getMaterialType(){return qn}loadMaterial(e){const t=this,s=this.json,n=this.extensions,i=s.materials[e];let r;const o={},a=i.extensions||{},l=[];if(a[P.KHR_MATERIALS_UNLIT]){const u=n[P.KHR_MATERIALS_UNLIT];r=u.getMaterialType(),l.push(u.extendParams(o,i,t))}else{const u=i.pbrMetallicRoughness||{};if(o.color=new ce(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const d=u.baseColorFactor;o.color.setRGB(d[0],d[1],d[2],Q),o.opacity=d[3]}u.baseColorTexture!==void 0&&l.push(t.assignTexture(o,"map",u.baseColorTexture,ye)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),l.push(t.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}i.doubleSided===!0&&(o.side=ji);const h=i.alphaMode||Dt.OPAQUE;if(h===Dt.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,h===Dt.MASK&&(o.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&r!==Le&&(l.push(t.assignTexture(o,"normalMap",i.normalTexture)),o.normalScale=new I(1,1),i.normalTexture.scale!==void 0)){const u=i.normalTexture.scale;o.normalScale.set(u,u)}if(i.occlusionTexture!==void 0&&r!==Le&&(l.push(t.assignTexture(o,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&r!==Le){const u=i.emissiveFactor;o.emissive=new ce().setRGB(u[0],u[1],u[2],Q)}return i.emissiveTexture!==void 0&&r!==Le&&l.push(t.assignTexture(o,"emissiveMap",i.emissiveTexture,ye)),Promise.all(l).then(function(){const u=new r(o);return i.name&&(u.name=i.name),ae(u,i),t.associations.set(u,{materials:e}),i.extensions&&Te(n,u,i),u})}createUniqueName(e){const t=Wi.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function i(o){return s[P.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(a){return Ns(a,o,t)})}const r=[];for(let o=0,a=e.length;o<a;o++){const l=e[o],h=io(l),u=n[h];if(u)r.push(u.promise);else{let d;l.extensions&&l.extensions[P.KHR_DRACO_MESH_COMPRESSION]?d=i(l):d=Ns(new bt,l,t),n[h]={primitive:l,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,n=this.extensions,i=s.meshes[e],r=i.primitives,o=[];for(let a=0,l=r.length;a<l;a++){const h=r[a].material===void 0?to(this.cache):this.getDependency("material",r[a].material);o.push(h)}return o.push(t.loadGeometries(r)),Promise.all(o).then(function(a){const l=a.slice(0,a.length-1),h=a[a.length-1],u=[];for(let f=0,p=h.length;f<p;f++){const m=h[f],g=r[f];let y;const _=l[f];if(g.mode===X.TRIANGLES||g.mode===X.TRIANGLE_STRIP||g.mode===X.TRIANGLE_FAN||g.mode===void 0)y=i.isSkinnedMesh===!0?new qi(m,_):new ds(m,_),y.isSkinnedMesh===!0&&y.normalizeSkinWeights(),g.mode===X.TRIANGLE_STRIP?y.geometry=Is(y.geometry,Bn):g.mode===X.TRIANGLE_FAN&&(y.geometry=Is(y.geometry,is));else if(g.mode===X.LINES)y=new Ki(m,_);else if(g.mode===X.LINE_STRIP)y=new Xi(m,_);else if(g.mode===X.LINE_LOOP)y=new Zi(m,_);else if(g.mode===X.POINTS)y=new Kn(m,_);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+g.mode);Object.keys(y.geometry.morphAttributes).length>0&&no(y,i),y.name=t.createUniqueName(i.name||"mesh_"+e),ae(y,i),g.extensions&&Te(n,y,g),t.assignFinalMaterial(y),u.push(y)}for(let f=0,p=u.length;f<p;f++)t.associations.set(u[f],{meshes:e,primitives:f});if(u.length===1)return i.extensions&&Te(n,u[0],i),u[0];const d=new De;i.extensions&&Te(n,d,i),t.associations.set(d,{meshes:e});for(let f=0,p=u.length;f<p;f++)d.add(u[f]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new $i(v.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new Xn(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),ae(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,i=t.joints.length;n<i;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const i=n.pop(),r=n,o=[],a=[];for(let l=0,h=r.length;l<h;l++){const u=r[l];if(u){o.push(u);const d=new L;i!==null&&d.fromArray(i.array,l*16),a.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new Yi(o,a)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],i=n.name?n.name:"animation_"+e,r=[],o=[],a=[],l=[],h=[];for(let u=0,d=n.channels.length;u<d;u++){const f=n.channels[u],p=n.samplers[f.sampler],m=f.target,g=m.node,y=n.parameters!==void 0?n.parameters[p.input]:p.input,_=n.parameters!==void 0?n.parameters[p.output]:p.output;m.node!==void 0&&(r.push(this.getDependency("node",g)),o.push(this.getDependency("accessor",y)),a.push(this.getDependency("accessor",_)),l.push(p),h.push(m))}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(h)]).then(function(u){const d=u[0],f=u[1],p=u[2],m=u[3],g=u[4],y=[];for(let _=0,A=d.length;_<A;_++){const x=d[_],T=f[_],E=p[_],M=m[_],S=g[_];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const w=s._createAnimationTracks(x,T,E,M,S);if(w)for(let C=0;C<w.length;C++)y.push(w[C])}return new Qi(i,void 0,y)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(i){const r=s._getNodeRef(s.meshCache,n.mesh,i);return n.weights!==void 0&&r.traverse(function(o){if(o.isMesh)for(let a=0,l=n.weights.length;a<l;a++)o.morphTargetInfluences[a]=n.weights[a]}),r})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],i=s._loadNodeShallow(e),r=[],o=n.children||[];for(let l=0,h=o.length;l<h;l++)r.push(s.getDependency("node",o[l]));const a=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([i,Promise.all(r),a]).then(function(l){const h=l[0],u=l[1],d=l[2];d!==null&&h.traverse(function(f){f.isSkinnedMesh&&f.bind(d,oo)});for(let f=0,p=u.length;f<p;f++)h.add(u[f]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],r=i.name?n.createUniqueName(i.name):"",o=[],a=n._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return a&&o.push(a),i.camera!==void 0&&o.push(n.getDependency("camera",i.camera).then(function(l){return n._getNodeRef(n.cameraCache,i.camera,l)})),n._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){o.push(l)}),this.nodeCache[e]=Promise.all(o).then(function(l){let h;if(i.isBone===!0?h=new Ji:l.length>1?h=new De:l.length===1?h=l[0]:h=new Gn,h!==l[0])for(let u=0,d=l.length;u<d;u++)h.add(l[u]);if(i.name&&(h.userData.name=i.name,h.name=r),ae(h,i),i.extensions&&Te(s,h,i),i.matrix!==void 0){const u=new L;u.fromArray(i.matrix),h.applyMatrix4(u)}else i.translation!==void 0&&h.position.fromArray(i.translation),i.rotation!==void 0&&h.quaternion.fromArray(i.rotation),i.scale!==void 0&&h.scale.fromArray(i.scale);return n.associations.has(h)||n.associations.set(h,{}),n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,i=new De;s.name&&(i.name=n.createUniqueName(s.name)),ae(i,s),s.extensions&&Te(t,i,s);const r=s.nodes||[],o=[];for(let a=0,l=r.length;a<l;a++)o.push(n.getDependency("node",r[a]));return Promise.all(o).then(function(a){for(let h=0,u=a.length;h<u;h++)i.add(a[h]);const l=h=>{const u=new Map;for(const[d,f]of n.associations)(d instanceof Pt||d instanceof As)&&u.set(d,f);return h.traverse(d=>{const f=n.associations.get(d);f!=null&&u.set(d,f)}),u};return n.associations=l(i),i})}_createAnimationTracks(e,t,s,n,i){const r=[],o=e.name?e.name:e.uuid,a=[];le[i.path]===le.weights?e.traverse(function(d){d.morphTargetInfluences&&a.push(d.name?d.name:d.uuid)}):a.push(o);let l;switch(le[i.path]){case le.weights:l=Ss;break;case le.rotation:l=Es;break;case le.translation:case le.scale:l=ws;break;default:switch(s.itemSize){case 1:l=Ss;break;case 2:case 3:default:l=ws;break}break}const h=n.interpolation!==void 0?eo[n.interpolation]:Zn,u=this._getArrayFromAccessor(s);for(let d=0,f=a.length;d<f;d++){const p=new l(a[d]+"."+le[i.path],t.array,u,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(p),r.push(p)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=ls(t.constructor),n=new Float32Array(t.length);for(let i=0,r=t.length;i<r;i++)n[i]=t[i]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof Es?Jr:di;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function co(c,e,t){const s=e.attributes,n=new $n;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],a=o.min,l=o.max;if(a!==void 0&&l!==void 0){if(n.set(new b(a[0],a[1],a[2]),new b(l[0],l[1],l[2])),o.normalized){const h=ls(Fe[o.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const o=new b,a=new b;for(let l=0,h=i.length;l<h;l++){const u=i[l];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],f=d.min,p=d.max;if(f!==void 0&&p!==void 0){if(a.setX(Math.max(Math.abs(f[0]),Math.abs(p[0]))),a.setY(Math.max(Math.abs(f[1]),Math.abs(p[1]))),a.setZ(Math.max(Math.abs(f[2]),Math.abs(p[2]))),d.normalized){const m=ls(Fe[d.componentType]);a.multiplyScalar(m)}o.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}c.boundingBox=n;const r=new fs;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,c.boundingSphere=r}function Ns(c,e,t){const s=e.attributes,n=[];function i(r,o){return t.getDependency("accessor",r).then(function(a){c.setAttribute(o,a)})}for(const r in s){const o=cs[r]||r.toLowerCase();o in c.attributes||n.push(i(s[r],o))}if(e.indices!==void 0&&!c.index){const r=t.getDependency("accessor",e.indices).then(function(o){c.setIndex(o)});n.push(r)}return os.workingColorSpace!==Q&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${os.workingColorSpace}" not supported.`),ae(c,e),co(c,e,t),Promise.all(n).then(function(){return e.targets!==void 0?so(c,e.targets,t):c})}class fi extends Cr{constructor(e=xt){super(),this.manager=e,this.adjustmentTransform=new L}parse(e){const t=super.parse(e),s=t.glbBytes.slice().buffer;return new Promise((n,i)=>{const r=this.manager,o=this.fetchOptions,a=r.getHandler("path.gltf")||new St(r);o.credentials==="include"&&o.mode==="cors"&&a.setCrossOrigin("use-credentials"),"credentials"in o&&a.setWithCredentials(o.credentials==="include"),o.headers&&a.setRequestHeader(o.headers);let l=this.workingPath;!/[\\/]$/.test(l)&&l.length&&(l+="/");const h=this.adjustmentTransform;a.parse(s,l,u=>{const{batchTable:d,featureTable:f}=t,{scene:p}=u,m=f.getData("RTC_CENTER");m&&(p.position.x+=m[0],p.position.y+=m[1],p.position.z+=m[2]),u.scene.updateMatrix(),u.scene.matrix.multiply(h),u.scene.matrix.decompose(u.scene.position,u.scene.quaternion,u.scene.scale),u.batchTable=d,u.featureTable=f,p.batchTable=d,p.featureTable=f,n(u)},i)})}}class lo extends wt{parse(e){const t=new DataView(e),s=Oe(t);console.assert(s==="pnts");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),o=t.getUint32(16,!0),a=t.getUint32(20,!0),l=t.getUint32(24,!0),h=28,u=e.slice(h,h+r+o),d=new At(u,0,r,o),f=h+r+o,p=e.slice(f,f+a+l),m=new ys(p,d.getData("BATCH_LENGTH")||d.getData("POINTS_LENGTH"),0,a,l);return Promise.resolve({version:n,featureTable:d,batchTable:m})}}function ho(c){const e=c>>11,t=c>>5&63,s=c&31,n=Math.round(e/31*255),i=Math.round(t/63*255),r=Math.round(s/31*255);return[n,i,r]}const ke=new I;function uo(c,e,t=new b){ke.set(c,e).divideScalar(256).multiplyScalar(2).subScalar(1),t.set(ke.x,ke.y,1-Math.abs(ke.x)-Math.abs(ke.y));const s=v.clamp(-t.z,0,1);return t.x>=0?t.setX(t.x-s):t.setX(t.x+s),t.y>=0?t.setY(t.y-s):t.setY(t.y+s),t.normalize(),t}const ks={RGB:"color",POSITION:"position"};class pi extends lo{constructor(e=xt){super(),this.manager=e}parse(e){return super.parse(e).then(async t=>{const{featureTable:s,batchTable:n}=t,i=new Wn,r=s.header.extensions,o=new b;let a;if(r&&r["3DTILES_draco_point_compression"]){const{byteOffset:u,byteLength:d,properties:f}=r["3DTILES_draco_point_compression"],p=this.manager.getHandler("draco.drc");if(p==null)throw new Error("PNTSLoader: dracoLoader not available.");const m={};for(const _ in f)if(_ in ks&&_ in f){const A=ks[_];m[A]=f[_]}const g={attributeIDs:m,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},y=s.getBuffer(u,d);a=await p.decodeGeometry(y,g),a.attributes.color&&(i.vertexColors=!0)}else{const u=s.getData("POINTS_LENGTH"),d=s.getData("POSITION",u,"FLOAT","VEC3"),f=s.getData("NORMAL",u,"FLOAT","VEC3"),p=s.getData("NORMAL",u,"UNSIGNED_BYTE","VEC2"),m=s.getData("RGB",u,"UNSIGNED_BYTE","VEC3"),g=s.getData("RGBA",u,"UNSIGNED_BYTE","VEC4"),y=s.getData("RGB565",u,"UNSIGNED_SHORT","SCALAR"),_=s.getData("CONSTANT_RGBA",u,"UNSIGNED_BYTE","VEC4"),A=s.getData("POSITION_QUANTIZED",u,"UNSIGNED_SHORT","VEC3"),x=s.getData("QUANTIZED_VOLUME_SCALE",u,"FLOAT","VEC3"),T=s.getData("QUANTIZED_VOLUME_OFFSET",u,"FLOAT","VEC3");if(a=new bt,A){const E=new Float32Array(u*3);for(let M=0;M<u;M++)for(let S=0;S<3;S++){const w=3*M+S;E[w]=A[w]/65535*x[S]}o.x=T[0],o.y=T[1],o.z=T[2],a.setAttribute("position",new z(E,3,!1))}else a.setAttribute("position",new z(d,3,!1));if(f!==null)a.setAttribute("normal",new z(f,3,!1));else if(p!==null){const E=new Float32Array(u*3),M=new b;for(let S=0;S<u;S++){const w=p[S*2],C=p[S*2+1],N=uo(w,C,M);E[S*3]=N.x,E[S*3+1]=N.y,E[S*3+2]=N.z}a.setAttribute("normal",new z(E,3,!1))}if(g!==null)a.setAttribute("color",new z(g,4,!0)),i.vertexColors=!0,i.transparent=!0,i.depthWrite=!1;else if(m!==null)a.setAttribute("color",new z(m,3,!0)),i.vertexColors=!0;else if(y!==null){const E=new Uint8Array(u*3);for(let M=0;M<u;M++){const S=ho(y[M]);for(let w=0;w<3;w++){const C=3*M+w;E[C]=S[w]}}a.setAttribute("color",new z(E,3,!0)),i.vertexColors=!0}else if(_!==null){const E=new ce(_[0],_[1],_[2]);i.color=E;const M=_[3]/255;M<1&&(i.opacity=M,i.transparent=!0,i.depthWrite=!1)}}const l=new Kn(a,i);l.position.copy(o),t.scene=l,t.scene.featureTable=s,t.scene.batchTable=n;const h=s.getData("RTC_CENTER");return h&&(t.scene.position.x+=h[0],t.scene.position.y+=h[1],t.scene.position.z+=h[2]),t})}}class fo extends wt{parse(e){const t=new DataView(e),s=Oe(t);console.assert(s==="i3dm");const n=t.getUint32(4,!0);console.assert(n===1);const i=t.getUint32(8,!0);console.assert(i===e.byteLength);const r=t.getUint32(12,!0),o=t.getUint32(16,!0),a=t.getUint32(20,!0),l=t.getUint32(24,!0),h=t.getUint32(28,!0),u=32,d=e.slice(u,u+r+o),f=new At(d,0,r,o),p=u+r+o,m=e.slice(p,p+a+l),g=new ys(m,f.getData("INSTANCES_LENGTH"),0,a,l),y=p+a+l,_=new Uint8Array(e,y,i-y);let A=null,x=null,T=null;if(h)A=_,x=Promise.resolve();else{const E=this.resolveExternalURL(li(_)),M=E.split(/[\\/]/g);M.pop(),T=M.join("/"),x=fetch(E,this.fetchOptions).then(S=>{if(!S.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${E}" with status ${S.status} : ${S.statusText}`);return S.arrayBuffer()}).then(S=>{A=new Uint8Array(S)})}return x.then(()=>({version:n,featureTable:f,batchTable:g,glbBytes:A,gltfWorkingPath:T}))}}new b;function po(c){const{x:e,y:t,z:s}=c;c.x=s,c.y=e,c.z=t}function mo(c){return-c+Math.PI/2}const Us=new ir,he=new b,q=new b,Ot=new b,ue=new L,te=new L,Nt=new fs,G=new Yn,Bs=new b,Vs=new b,zs=new b,Ue=new b,Gs=new Se,go=1e-12,yo=.1,kt=0,Hs=1,js=2;class _s{constructor(e=1,t=1,s=1){this.name="",this.radius=new b(e,t,s)}intersectRay(e,t){return ue.makeScale(...this.radius).invert(),Nt.center.set(0,0,0),Nt.radius=1,Gs.copy(e).applyMatrix4(ue),Gs.intersectSphere(Nt,t)?(ue.makeScale(...this.radius),t.applyMatrix4(ue),t):null}getEastNorthUpFrame(e,t,s){return this.getEastNorthUpAxes(e,t,Bs,Vs,zs,Ue),s.makeBasis(Bs,Vs,zs).setPosition(Ue)}getEastNorthUpAxes(e,t,s,n,i,r=Ue){this.getCartographicToPosition(e,t,0,r),this.getCartographicToNormal(e,t,i),s.set(-r.y,r.x,0).normalize(),n.crossVectors(i,s).normalize()}getAzElRollFromRotationMatrix(e,t,s,n,i=kt){return i===Hs?(G.set(-Math.PI/2,0,0,"XYZ"),te.makeRotationFromEuler(G).premultiply(s)):i===js?(G.set(-Math.PI/2,0,Math.PI,"XYZ"),te.makeRotationFromEuler(G).premultiply(s)):te.copy(s),this.getEastNorthUpFrame(e,t,ue).invert(),te.premultiply(ue),G.setFromRotationMatrix(te,"ZXY"),n.azimuth=-G.z,n.elevation=G.x,n.roll=G.y,n}getRotationMatrixFromAzElRoll(e,t,s,n,i,r,o=kt){return this.getEastNorthUpFrame(e,t,ue),G.set(n,i,-s,"ZXY"),r.makeRotationFromEuler(G).premultiply(ue).setPosition(0,0,0),o===Hs?(G.set(Math.PI/2,0,0,"XYZ"),te.makeRotationFromEuler(G),r.multiply(te)):o===js&&(G.set(-Math.PI/2,0,Math.PI,"XYZ"),te.makeRotationFromEuler(G),r.multiply(te)),r}getFrame(e,t,s,n,i,r,o,a=kt){return this.getRotationMatrixFromAzElRoll(e,t,s,n,i,o,a),this.getCartographicToPosition(e,t,r,Ue),o.setPosition(Ue),o}getCartographicToPosition(e,t,s,n){this.getCartographicToNormal(e,t,he);const i=this.radius;q.copy(he),q.x*=i.x**2,q.y*=i.y**2,q.z*=i.z**2;const r=Math.sqrt(he.dot(q));return q.divideScalar(r),n.copy(q).addScaledVector(he,s)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,q),this.getPositionToNormal(e,he);const s=Ot.subVectors(e,q);return t.lon=Math.atan2(he.y,he.x),t.lat=Math.asin(he.z),t.height=Math.sign(s.dot(e))*s.length(),t}getCartographicToNormal(e,t,s){return Us.set(1,mo(e),t),s.setFromSpherical(Us).normalize(),po(s),s}getPositionToNormal(e,t){const s=this.radius;return t.copy(e),t.x/=s.x**2,t.y/=s.y**2,t.z/=s.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const s=this.radius,n=1/s.x**2,i=1/s.y**2,r=1/s.z**2,o=e.x*e.x*n,a=e.y*e.y*i,l=e.z*e.z*r,h=o+a+l,u=Math.sqrt(1/h),d=q.copy(e).multiplyScalar(u);if(h<yo)return isFinite(u)?t.copy(d):null;const f=Ot.set(d.x*n*2,d.y*i*2,d.z*r*2);let p=(1-u)*e.length()/(.5*f.length()),m=0,g,y,_,A,x,T,E,M,S,w,C;do{p-=m,_=1/(1+p*n),A=1/(1+p*i),x=1/(1+p*r),T=_*_,E=A*A,M=x*x,S=T*_,w=E*A,C=M*x,g=o*T+a*E+l*M-1,y=o*S*n+a*w*i+l*C*r;const N=-2*y;m=g/N}while(Math.abs(g)>go);return t.set(e.x*_,e.y*A,e.z*x)}calculateHorizonDistance(e,t){const s=this.calculateEffectiveRadius(e);return Math.sqrt(2*s*t+t**2)}calculateEffectiveRadius(e){const t=this.radius.x,n=1-this.radius.z**2/t**2,i=e*v.DEG2RAD,r=Math.sin(i)**2;return t/Math.sqrt(1-n*r)}getPositionElevation(e){this.getPositionToSurfacePoint(e,q);const t=Ot.subVectors(e,q);return Math.sign(t.dot(e))*t.length()}copy(e){return this.radius.copy(e.radius),this}clone(){return new this.constructor().copy(this)}}const Et=new _s(vs,vs,xr);Et.name="WGS84 Earth";const Ws=new b,Ut=new b,Bt=new b,Vt=new b,zt=new ee,rt=new b,ot=new L,qs=new L,Ks=new b,Xs=new L,Gt=new ee,Ht={};class mi extends fo{constructor(e=xt){super(),this.manager=e,this.adjustmentTransform=new L,this.ellipsoid=Et.clone()}resolveExternalURL(e){return this.manager.resolveURL(super.resolveExternalURL(e))}parse(e){return super.parse(e).then(t=>{const{featureTable:s,batchTable:n}=t,i=t.glbBytes.slice().buffer;return new Promise((r,o)=>{const a=this.fetchOptions,l=this.manager,h=l.getHandler("path.gltf")||new St(l);a.credentials==="include"&&a.mode==="cors"&&h.setCrossOrigin("use-credentials"),"credentials"in a&&h.setWithCredentials(a.credentials==="include"),a.headers&&h.setRequestHeader(a.headers);let u=t.gltfWorkingPath??this.workingPath;/[\\/]$/.test(u)||(u+="/");const d=this.adjustmentTransform;h.parse(i,u,f=>{const p=s.getData("INSTANCES_LENGTH"),m=s.getData("POSITION",p,"FLOAT","VEC3"),g=s.getData("NORMAL_UP",p,"FLOAT","VEC3"),y=s.getData("NORMAL_RIGHT",p,"FLOAT","VEC3"),_=s.getData("SCALE_NON_UNIFORM",p,"FLOAT","VEC3"),A=s.getData("SCALE",p,"FLOAT","SCALAR"),x=s.getData("RTC_CENTER"),T=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(w=>{w in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${w}" detected.`)});const E=new b;for(let w=0;w<p;w++)E.x+=m[w*3+0]/p,E.y+=m[w*3+1]/p,E.z+=m[w*3+2]/p;const M=[],S=[];f.scene.updateMatrixWorld(),f.scene.traverse(w=>{if(w.isMesh){S.push(w);const{geometry:C,material:N}=w,W=new zn(C,N,p);W.position.copy(E),x&&(W.position.x+=x[0],W.position.y+=x[1],W.position.z+=x[2]),M.push(W)}});for(let w=0;w<p;w++){Vt.set(m[w*3+0]-E.x,m[w*3+1]-E.y,m[w*3+2]-E.z),zt.identity(),g&&(Ut.set(g[w*3+0],g[w*3+1],g[w*3+2]),Bt.set(y[w*3+0],y[w*3+1],y[w*3+2]),Ws.crossVectors(Bt,Ut).normalize(),ot.makeBasis(Bt,Ut,Ws),zt.setFromRotationMatrix(ot)),rt.set(1,1,1),_&&rt.set(_[w*3+0],_[w*3+1],_[w*3+2]),A&&rt.multiplyScalar(A[w]);for(let C=0,N=M.length;C<N;C++){const W=M[C];Gt.copy(zt),T&&(W.updateMatrixWorld(),Ks.copy(Vt).applyMatrix4(W.matrixWorld),this.ellipsoid.getPositionToCartographic(Ks,Ht),this.ellipsoid.getEastNorthUpFrame(Ht.lat,Ht.lon,Xs),Gt.setFromRotationMatrix(Xs)),ot.compose(Vt,Gt,rt).multiply(d);const Ct=S[C];qs.multiplyMatrices(ot,Ct.matrixWorld),W.setMatrixAt(w,qs)}}f.scene.clear(),f.scene.add(...M),f.batchTable=n,f.featureTable=s,f.scene.batchTable=n,f.scene.featureTable=s,r(f)},o)})})}}class _o extends wt{parse(e){const t=new DataView(e),s=Oe(t);console.assert(s==="cmpt",'CMPTLoader: The magic bytes equal "cmpt".');const n=t.getUint32(4,!0);console.assert(n===1,'CMPTLoader: The version listed in the header is "1".');const i=t.getUint32(8,!0);console.assert(i===e.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const r=t.getUint32(12,!0),o=[];let a=16;for(let l=0;l<r;l++){const h=new DataView(e,a,12),u=Oe(h),d=h.getUint32(4,!0),f=h.getUint32(8,!0),p=new Uint8Array(e,a,f);o.push({type:u,buffer:p,version:d}),a+=f}return{version:n,tiles:o}}}class To extends _o{constructor(e=xt){super(),this.manager=e,this.adjustmentTransform=new L,this.ellipsoid=Et.clone()}parse(e){const t=super.parse(e),{manager:s,ellipsoid:n,adjustmentTransform:i}=this,r=[];for(const o in t.tiles){const{type:a,buffer:l}=t.tiles[o];switch(a){case"b3dm":{const h=l.slice(),u=new fi(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions,u.adjustmentTransform.copy(i);const d=u.parse(h.buffer);r.push(d);break}case"pnts":{const h=l.slice(),u=new pi(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions;const d=u.parse(h.buffer);r.push(d);break}case"i3dm":{const h=l.slice(),u=new mi(s);u.workingPath=this.workingPath,u.fetchOptions=this.fetchOptions,u.ellipsoid.copy(n),u.adjustmentTransform.copy(i);const d=u.parse(h.buffer);r.push(d);break}}}return Promise.all(r).then(o=>{const a=new De;return o.forEach(l=>{a.add(l.scene)}),{tiles:o,scene:a}})}}const Be=new L;class bo extends De{constructor(e){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=e,this.matrixWorldInverse=new L}raycast(e,t){return this.tilesRenderer.optimizeRaycast?(this.tilesRenderer.raycast(e,t),!1):!0}updateMatrixWorld(e){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||e){this.parent===null?Be.copy(this.matrix):Be.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=Be.elements,s=this.matrixWorld.elements;let n=!1;for(let i=0;i<16;i++){const r=t[i],o=s[i];if(Math.abs(r-o)>Number.EPSILON){n=!0;break}}if(n){this.matrixWorld.copy(Be),this.matrixWorldInverse.copy(Be).invert();const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].updateMatrixWorld()}}}}const gi=new Se,jt=new b,at=[];function yi(c,e){return c.distance-e.distance}function _i(c,e,t,s){const{scene:n}=c.cached;t.invokeOnePlugin(r=>r.raycastTile&&r.raycastTile(c,n,e,s))||e.intersectObject(n,!0,s)}function xo(c,e,t){_i(c,e,t,at),at.sort(yi);const s=at[0]||null;return at.length=0,s}function Ti(c){return"__used"in c}function bi(c,e,t,s=null){const{group:n,activeTiles:i}=c;s===null&&(s=gi,s.copy(t.ray).applyMatrix4(n.matrixWorldInverse));const r=[],o=e.children;for(let h=0,u=o.length;h<u;h++){const d=o[h];if(!Ti(d)||!d.__used)continue;d.cached.boundingVolume.intersectRay(s,jt)!==null&&(jt.applyMatrix4(n.matrixWorld),r.push({distance:jt.distanceToSquared(t.ray.origin),tile:d}))}r.sort(yi);let a=null,l=1/0;if(i.has(e)){const h=xo(e,t,c);h&&(a=h,l=h.distance*h.distance)}for(let h=0,u=r.length;h<u;h++){const d=r[h],f=d.distance,p=d.tile;if(f>l)break;const m=bi(c,p,t,s);if(m){const g=m.distance*m.distance;g<l&&(a=m,l=g)}}return a}function xi(c,e,t,s,n=null){if(!Ti(e))return;const{group:i,activeTiles:r}=c,{boundingVolume:o}=e.cached;if(n===null&&(n=gi,n.copy(t.ray).applyMatrix4(i.matrixWorldInverse)),!e.__used||!o.intersectsRay(n))return;r.has(e)&&_i(e,t,c,s);const a=e.children;for(let l=0,h=a.length;l<h;l++)xi(c,a[l],t,s,n)}const ct=new b,lt=new b,H=new b,ht=new Se;class Zs{constructor(e=new $n,t=new L){this.box=e.clone(),this.transform=t.clone(),this.inverseTransform=new L,this.points=new Array(8).fill().map(()=>new b),this.planes=new Array(6).fill().map(()=>new ps)}copy(e){return this.box.copy(e.box),this.transform.copy(e.transform),this.update(),this}clone(){return new this.constructor().copy(this)}clampPoint(e,t){return t.copy(e).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(e){return this.clampPoint(e,H).distanceTo(e)}containsPoint(e){return H.copy(e).applyMatrix4(this.inverseTransform),this.box.containsPoint(H)}intersectsRay(e){return ht.copy(e).applyMatrix4(this.inverseTransform),ht.intersectsBox(this.box)}intersectRay(e,t){return ht.copy(e).applyMatrix4(this.inverseTransform),ht.intersectBox(this.box,t)?(t.applyMatrix4(this.transform),t):null}update(){const{points:e,inverseTransform:t,transform:s,box:n}=this;t.copy(s).invert();const{min:i,max:r}=n;let o=0;for(let a=-1;a<=1;a+=2)for(let l=-1;l<=1;l+=2)for(let h=-1;h<=1;h+=2)e[o].set(a<0?i.x:r.x,l<0?i.y:r.y,h<0?i.z:r.z).applyMatrix4(s),o++;this.updatePlanes()}updatePlanes(){ct.copy(this.box.min).applyMatrix4(this.transform),lt.copy(this.box.max).applyMatrix4(this.transform),H.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(H,ct),this.planes[1].setFromNormalAndCoplanarPoint(H,lt).negate(),H.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(H,ct),this.planes[3].setFromNormalAndCoplanarPoint(H,lt).negate(),H.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(H,ct),this.planes[5].setFromNormalAndCoplanarPoint(H,lt).negate()}intersectsSphere(e){return this.clampPoint(e.center,H),H.distanceToSquared(e.center)<=e.radius*e.radius}intersectsFrustum(e){return this._intersectsPlaneShape(e.planes,e.points)}intersectsOBB(e){return this._intersectsPlaneShape(e.planes,e.points)}_intersectsPlaneShape(e,t){const s=this.points,n=this.planes;for(let i=0;i<6;i++){const r=e[i];let o=-1/0;for(let a=0;a<8;a++){const l=s[a],h=r.distanceToPoint(l);o=o<h?h:o}if(o<0)return!1}for(let i=0;i<6;i++){const r=n[i];let o=-1/0;for(let a=0;a<8;a++){const l=t[a],h=r.distanceToPoint(l);o=o<h?h:o}if(o<0)return!1}return!0}}const pe=Math.PI,ut=pe/2,Ve=new b,Ee=new b,Me=new b,$s=new L;let $e=0;const Wt=[];function Ao(c=!1){return c?(Wt[$e]||(Wt[$e]=new b),$e++,Wt[$e-1]):new b}function Ys(){$e=0}class wo extends _s{constructor(e,t,s,n=-ut,i=ut,r=0,o=2*pe,a=0,l=0){super(e,t,s),this.latStart=n,this.latEnd=i,this.lonStart=r,this.lonEnd=o,this.heightStart=a,this.heightEnd=l}_getPoints(e=!1){const{latStart:t,latEnd:s,lonStart:n,lonEnd:i,heightStart:r,heightEnd:o}=this,a=v.mapLinear(.5,0,1,t,s),l=v.mapLinear(.5,0,1,n,i),h=Math.floor(n/ut)*ut,u=[[-pe/2,0],[pe/2,0],[0,h],[0,h+pe/2],[0,h+pe],[0,h+3*pe/2],[t,i],[s,i],[t,n],[s,n],[0,n],[0,i],[a,l],[t,l],[s,l],[a,n],[a,i]],d=[],f=u.length;for(let p=0;p<=1;p++){const m=v.mapLinear(p,0,1,r,o);for(let g=0,y=f;g<y;g++){const[_,A]=u[g];if(_>=t&&_<=s&&A>=n&&A<=i){const x=Ao(e);d.push(x),this.getCartographicToPosition(_,A,m,x)}}}return d}getBoundingBox(e,t){Ys();const{latStart:s,latEnd:n,lonStart:i,lonEnd:r}=this;if(n-s<pe/2){const l=v.mapLinear(.5,0,1,s,n),h=v.mapLinear(.5,0,1,i,r);this.getCartographicToNormal(l,h,Me),Ee.set(0,0,1),Ve.crossVectors(Ee,Me),Ee.crossVectors(Ve,Me),t.makeBasis(Ve,Ee,Me)}else Ve.set(1,0,0),Ee.set(0,1,0),Me.set(0,0,1),t.makeBasis(Ve,Ee,Me);$s.copy(t).invert();const a=this._getPoints(!0);for(let l=0,h=a.length;l<h;l++)a[l].applyMatrix4($s);e.makeEmpty(),e.setFromPoints(a)}getBoundingSphere(e,t){Ys();const s=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(s,t)}}const se=new b,ne=new b,ie=new b,Qs=new b,Js=new b;class So{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(e){const t=this.sphere,s=this.obb||this.regionObb;return!(t&&!e.intersectsSphere(t)||s&&!s.intersectsRay(e))}intersectRay(e,t=null){const s=this.sphere,n=this.obb||this.regionObb;let i=-1/0,r=-1/0;s&&e.intersectSphere(s,Qs)&&(i=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(Qs)),n&&n.intersectRay(e,Js)&&(r=n.containsPoint(e.origin)?0:e.origin.distanceToSquared(Js));const o=Math.max(i,r);return o===-1/0?null:(e.at(Math.sqrt(o),t),t)}distanceToPoint(e){const t=this.sphere,s=this.obb||this.regionObb;let n=-1/0,i=-1/0;return t&&(n=Math.max(t.distanceToPoint(e),0)),s&&(i=s.distanceToPoint(e)),n>i?n:i}intersectsFrustum(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsFrustum(e)?!1:!!(s||t)}intersectsSphere(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!s.intersectsSphere(e)||t&&!t.intersectsSphere(e)?!1:!!(s||t)}intersectsOBB(e){const t=this.obb||this.regionObb,s=this.sphere;return s&&!e.intersectsSphere(s)||t&&!t.intersectsOBB(e)?!1:!!(s||t)}getOBB(e,t){const s=this.obb||this.regionObb;s?(e.copy(s.box),t.copy(s.transform)):(this.getAABB(e),t.identity())}getAABB(e){if(this.sphere)this.sphere.getBoundingBox(e);else{const t=this.obb||this.regionObb;e.copy(t.box).applyMatrix4(t.transform)}}getSphere(e){if(this.sphere)e.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(e);else{const t=this.obb||this.regionObb;t.box.getBoundingSphere(e),e.applyMatrix4(t.transform)}}setObbData(e,t){const s=new Zs;se.set(e[3],e[4],e[5]),ne.set(e[6],e[7],e[8]),ie.set(e[9],e[10],e[11]);const n=se.length(),i=ne.length(),r=ie.length();se.normalize(),ne.normalize(),ie.normalize(),n===0&&se.crossVectors(ne,ie),i===0&&ne.crossVectors(se,ie),r===0&&ie.crossVectors(se,ne),s.transform.set(se.x,ne.x,ie.x,e[0],se.y,ne.y,ie.y,e[1],se.z,ne.z,ie.z,e[2],0,0,0,1).premultiply(t),s.box.min.set(-n,-i,-r),s.box.max.set(n,i,r),s.update(),this.obb=s}setSphereData(e,t,s,n,i){const r=new fs;r.center.set(e,t,s),r.radius=n,r.applyMatrix4(i),this.sphere=r}setRegionData(e,t,s,n,i,r,o){const a=new wo(...e.radius,s,i,t,n,r,o),l=new Zs;a.getBoundingBox(l.box,l.transform),l.update(),this.region=a,this.regionObb=l}}const Eo=new Qn;function Mo(c,e,t,s){const n=Eo.set(c.normal.x,c.normal.y,c.normal.z,e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z);return s.set(-c.constant,-e.constant,-t.constant),s.applyMatrix3(n.invert()),s}class Co extends rr{constructor(){super(),this.points=Array(8).fill().map(()=>new b)}setFromProjectionMatrix(e,t){return super.setFromProjectionMatrix(e,t),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach((n,i)=>{Mo(n[0],n[1],n[2],t[i])})}}function Po(c){const{TextureUtils:e}=or;if(!e)return 0;const t=new Set;let s=0;return c.traverse(n=>{if(n.geometry&&!t.has(n.geometry)&&(s+=Pr(n.geometry),t.add(n.geometry)),n.material){const i=n.material;for(const r in i){const o=i[r];if(o&&o.isTexture&&!t.has(o)){const{format:a,type:l,image:h}=o,{width:u,height:d}=h,f=e.getByteLength(u,d,a,l);s+=o.generateMipmaps?f*4/3:f,t.add(o)}}}}),s}const en=new L,tn=new Yn,Ai=Symbol("INITIAL_FRUSTUM_CULLED"),dt=new L,ze=new b,qt=new I,ft={inView:!1,error:1/0},Ro=new b(1,0,0),vo=new b(0,1,0);function sn(c,e){c.traverse(t=>{t.frustumCulled=t[Ai]&&e})}class Lo extends Sr{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.forEachLoadedModel(t=>{sn(t,!e)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(e){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=e}constructor(...e){super(...e),this.group=new bo(this),this.ellipsoid=Et.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new L,this.lruCache.computeMemoryUsageCallback=s=>s.cached.bytesUsed??null,this._autoDisableRendererCulling=!0;const t=new ar;t.setURLModifier(s=>this.preprocessURL?this.preprocessURL(s):s),this.manager=t,this._listeners={}}addEventListener(...e){Ze.prototype.addEventListener.call(this,...e)}hasEventListener(...e){Ze.prototype.hasEventListener.call(this,...e)}removeEventListener(...e){Ze.prototype.removeEventListener.call(this,...e)}dispatchEvent(...e){Ze.prototype.dispatchEvent.call(this,...e)}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return t?(t.getAABB(e),!0):!1}getOrientedBoundingBox(e,t){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return s?(s.getOBB(e,t),!0):!1}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return t?(t.getSphere(e),!0):!1}forEachLoadedModel(e){this.traverse(t=>{const s=t.cached&&t.cached.scene;s&&e(s,t)},null,!1)}raycast(e,t){if(this.root)if(e.firstHitOnly){const s=bi(this,this.root,e);s&&t.push(s)}else xi(this,this.root,e,t)}hasCamera(e){return this.cameraMap.has(e)}setCamera(e){const t=this.cameras,s=this.cameraMap;return s.has(e)?!1:(s.set(e,new I),t.push(e),this.dispatchEvent({type:"add-camera",camera:e}),!0)}setResolution(e,t,s){const n=this.cameraMap;if(!n.has(e))return!1;const i=t.isVector2?t.x:t,r=t.isVector2?t.y:s,o=n.get(e);return(o.width!==i||o.height!==r)&&(o.set(i,r),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(e,t){return t.getSize(qt).multiplyScalar(t.getPixelRatio()),this.setResolution(e,qt.x,qt.y)}deleteCamera(e){const t=this.cameras,s=this.cameraMap;if(s.has(e)){const n=t.indexOf(e);return t.splice(n,1),s.delete(e),this.dispatchEvent({type:"delete-camera",camera:e}),!0}return!1}loadRootTileSet(...e){return super.loadRootTileSet(...e).then(t=>{const{asset:s,extensions:n={}}=t;switch((s&&s.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(vo,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(Ro,Math.PI/2);break}if("3DTILES_ellipsoid"in n){const r=n["3DTILES_ellipsoid"],{ellipsoid:o}=this;o.name=r.body,r.radii?o.radius.set(...r.radii):o.radius.set(1,1,1)}return t})}update(){let e=null;if(this.invokeAllPlugins(r=>{if(r.doTilesNeedUpdate){const o=r.doTilesNeedUpdate();e===null?e=o:e=!!(e||o)}}),e===!1){this.dispatchEvent({type:"update-before"}),this.dispatchEvent({type:"update-after"});return}this.dispatchEvent({type:"update-before"});const t=this.group,s=this.cameras,n=this.cameraMap,i=this.cameraInfo;if(s.length===0){let r=!1;if(this.invokeAllPlugins(o=>r=r||!!(o!==this&&o.calculateTileViewError)),r===!1){console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.");return}}for(;i.length>s.length;)i.pop();for(;i.length<s.length;)i.push({frustum:new Co,isOrthographic:!1,sseDenominator:-1,position:new b,invScale:-1,pixelSize:0});ze.setFromMatrixScale(t.matrixWorldInverse),Math.abs(Math.max(ze.x-ze.y,ze.x-ze.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let r=0,o=i.length;r<o;r++){const a=s[r],l=i[r],h=l.frustum,u=l.position,d=n.get(a);(d.width===0||d.height===0)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const f=a.projectionMatrix.elements;if(l.isOrthographic=f[15]===1,l.isOrthographic){const p=2/f[0],m=2/f[5];l.pixelSize=Math.max(m/d.height,p/d.width)}else l.sseDenominator=2/f[5]/d.height;dt.copy(t.matrixWorld),dt.premultiply(a.matrixWorldInverse),dt.premultiply(a.projectionMatrix),h.setFromProjectionMatrix(dt),u.set(0,0,0),u.applyMatrix4(a.matrixWorld),u.applyMatrix4(t.matrixWorldInverse)}super.update(),this.dispatchEvent({type:"update-after"})}preprocessNode(e,t,s=null){super.preprocessNode(e,t,s);const n=new L;if(e.transform){const o=e.transform;for(let a=0;a<16;a++)n.elements[a]=o[a]}s&&n.premultiply(s.cached.transform);const i=new L().copy(n).invert(),r=new So;"sphere"in e.boundingVolume&&r.setSphereData(...e.boundingVolume.sphere,n),"box"in e.boundingVolume&&r.setObbData(e.boundingVolume.box,n),"region"in e.boundingVolume&&r.setRegionData(this.ellipsoid,...e.boundingVolume.region),e.cached={transform:n,transformInverse:i,active:!1,boundingVolume:r,metadata:null,scene:null,geometry:null,materials:null,textures:null}}async parseTile(e,t,s,n,i){const r=t.cached,o=n.split(/[\\/]/g);o.pop();const a=o.join("/"),l=this.fetchOptions,h=this.manager;let u=null;const d=r.transform,f=this._upRotationMatrix,p=(Oe(e)||s).toLowerCase();switch(p){case"b3dm":{const T=new fi(h);T.workingPath=a,T.fetchOptions=l,T.adjustmentTransform.copy(f),u=T.parse(e);break}case"pnts":{const T=new pi(h);T.workingPath=a,T.fetchOptions=l,u=T.parse(e);break}case"i3dm":{const T=new mi(h);T.workingPath=a,T.fetchOptions=l,T.adjustmentTransform.copy(f),T.ellipsoid.copy(this.ellipsoid),u=T.parse(e);break}case"cmpt":{const T=new To(h);T.workingPath=a,T.fetchOptions=l,T.adjustmentTransform.copy(f),T.ellipsoid.copy(this.ellipsoid),u=T.parse(e).then(E=>E.scene);break}case"gltf":case"glb":{const T=h.getHandler("path.gltf")||h.getHandler("path.glb")||new St(h);T.setWithCredentials(l.credentials==="include"),T.setRequestHeader(l.headers||{}),l.credentials==="include"&&l.mode==="cors"&&T.setCrossOrigin("use-credentials");let E=T.resourcePath||T.path||a;!/[\\/]$/.test(E)&&E.length&&(E+="/"),u=T.parseAsync(e,E).then(M=>{M.scene=M.scene||new De;const{scene:S}=M;return S.updateMatrix(),S.matrix.multiply(f).decompose(S.position,S.quaternion,S.scale),M});break}default:{u=this.invokeOnePlugin(T=>T.parseToMesh&&T.parseToMesh(e,t,s,n,i));break}}const m=await u;if(m===null)throw new Error(`TilesRenderer: Content type "${p}" not supported.`);let g,y;m.isObject3D?(g=m,y=null):(g=m.scene,y=m),await this.invokeAllPlugins(T=>T.processTileModel&&T.processTileModel(g,t)),g.updateMatrix(),g.matrix.premultiply(d),g.matrix.decompose(g.position,g.quaternion,g.scale),g.traverse(T=>{T[Ai]=T.frustumCulled}),sn(g,!this.autoDisableRendererCulling);const _=[],A=[],x=[];if(g.traverse(T=>{if(T.geometry&&A.push(T.geometry),T.material){const E=T.material;_.push(T.material);for(const M in E){const S=E[M];S&&S.isTexture&&x.push(S)}}}),i.aborted){for(let T=0,E=x.length;T<E;T++){const M=x[T];M.image instanceof ImageBitmap&&M.image.close(),M.dispose()}return}r.materials=_,r.geometry=A,r.textures=x,r.scene=g,r.metadata=y,r.bytesUsed=Po(g)}disposeTile(e){super.disposeTile(e);const t=e.cached;if(t.scene){const s=t.materials,n=t.geometry,i=t.textures,r=t.scene.parent;t.scene.traverse(o=>{o.userData.meshFeatures&&o.userData.meshFeatures.dispose(),o.userData.structuralMetadata&&o.userData.structuralMetadata.dispose()});for(let o=0,a=n.length;o<a;o++)n[o].dispose();for(let o=0,a=s.length;o<a;o++)s[o].dispose();for(let o=0,a=i.length;o<a;o++){const l=i[o];l.image instanceof ImageBitmap&&l.image.close(),l.dispose()}r&&r.remove(t.scene),this.dispatchEvent({type:"dispose-model",scene:t.scene,tile:e}),t.scene=null,t.materials=null,t.textures=null,t.geometry=null,t.metadata=null}}setTileVisible(e,t){const s=e.cached.scene,n=this.group;t?s&&(n.add(s),s.updateMatrixWorld(!0)):s&&n.remove(s),super.setTileVisible(e,t),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:e,visible:t})}calculateTileViewError(e,t){const s=e.cached,n=this.cameras,i=this.cameraInfo,r=s.boundingVolume;let o=!1,a=-1/0,l=1/0,h=-1/0,u=1/0;for(let d=0,f=n.length;d<f;d++){const p=i[d];let m,g;if(p.isOrthographic){const _=p.pixelSize;m=e.geometricError/_,g=1/0}else{const _=p.sseDenominator;g=r.distanceToPoint(p.position),m=e.geometricError/(g*_)}const y=i[d].frustum;r.intersectsFrustum(y)&&(o=!0,a=Math.max(a,m),l=Math.min(l,g)),h=Math.max(h,m),u=Math.min(u,g)}this.invokeAllPlugins(d=>{d!==this&&d.calculateTileViewError&&(d.calculateTileViewError(e,ft),ft.inView&&(o=!0,a=Math.max(a,ft.error)),h=Math.max(h,ft.error))}),o?(t.inView=!0,t.error=a,t.distanceToCamera=l):(t.inView=!1,t.error=h,t.distanceToCamera=u)}setLatLonToYUp(e,t){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:n}=this;tn.set(Math.PI/2,Math.PI/2,0),en.makeRotationFromEuler(tn),s.getEastNorthUpFrame(e,t,n.matrix).multiply(en).invert().decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}}class Io extends ds{constructor(){super(new cr(0,0),new Do),this.renderOrder=1/0}onBeforeRender(e){const t=this.material.uniforms;e.getSize(t.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class Do extends Jn{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new I},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const nn=new I,rn=new I;class Fo{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new I,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new I,this.hoverSet=!1}updateFrame(){const{previousPositions:e,pointerPositions:t}=this;for(const s in t)e[s].copy(t[s])}setHoverEvent(e){(e.pointerType==="mouse"||e.type==="wheel")&&(this.getAdjustedPointer(e,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(e){return this.pointerType!==null?(this.getCenterPoint(e),e):this.hoverSet?(e.copy(this.hoverPosition),e):null}getAdjustedPointer(e,t){const n=(this.domElement?this.domElement:e.target).getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top;t.set(i,r)}addPointer(e){const t=e.pointerId,s=new I;this.getAdjustedPointer(e,s),this.pointerOrder.push(t),this.pointerPositions[t]=s,this.previousPositions[t]=s.clone(),this.startPositions[t]=s.clone(),this.getPointerCount()===1&&(this.pointerType=e.pointerType,this.buttons=e.buttons)}updatePointer(e){const t=e.pointerId;return t in this.pointerPositions?(this.getAdjustedPointer(e,this.pointerPositions[t]),!0):!1}deletePointer(e){const t=e.pointerId,s=this.pointerOrder;s.splice(s.indexOf(t),1),delete this.pointerPositions[t],delete this.previousPositions[t],delete this.startPositions[t],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(e,t=this.pointerPositions){const s=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const n=s[0];return e.copy(t[n]),e}else if(this.getPointerCount()===2){const n=this.pointerOrder[0],i=this.pointerOrder[1],r=t[n],o=t[i];return e.addVectors(r,o).multiplyScalar(.5),e}return null}getPreviousCenterPoint(e){return this.getCenterPoint(e,this.previousPositions)}getStartCenterPoint(e){return this.getCenterPoint(e,this.startPositions)}getMoveDistance(){return this.getCenterPoint(nn),this.getPreviousCenterPoint(rn),nn.sub(rn).length()}getTouchPointerDistance(e=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:t}=this,s=t[0],n=t[1],i=e[s],r=e[n];return i.distanceTo(r)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const me=new L,on=new Se,hs=new b;function we(c,e,t){return t.makeTranslation(-c.x,-c.y,-c.z),me.makeRotationFromQuaternion(e),t.premultiply(me),me.makeTranslation(c.x,c.y,c.z),t.premultiply(me),t}function Re(c,e,t,s){s.x=(c-t.offsetLeft)/t.clientWidth*2-1,s.y=-((e-t.offsetTop)/t.clientHeight)*2+1,s.isVector3&&(s.z=0)}function Kt(c,e,t){return e.intersectRay(c,t)?t:(me.makeScale(...e.radius).invert(),on.copy(c).applyMatrix4(me),hs.set(0,0,0),on.closestPointToPoint(hs,t).normalize(),me.makeScale(...e.radius),t.applyMatrix4(me))}function Oo(c,e,t){const s=c.origin.length(),n=Math.acos(e/s);t.copy(c.origin).multiplyScalar(-1).normalize();const i=hs.crossVectors(t,c.direction).normalize();t.multiplyScalar(-1).applyAxisAngle(i,-n).normalize().multiplyScalar(e)}function Z(c,e,t){const s=c instanceof Se?c:c.ray,{origin:n,direction:i}=s;n.set(e.x,e.y,-1).unproject(t),i.set(e.x,e.y,1).unproject(t).sub(n),c.isRay||(c.near=0,c.far=i.length(),c.camera=t),i.normalize()}const Y=0,Ae=1,be=2,ve=3,Xt=4,Zt=.05,$t=.025,de=new L,j=new b,D=new b,Ge=new b,an=new b,Ce=new b,fe=new ee,cn=new ps,V=new b,pt=new b,Yt=new b,No=new ee,F=new Se,He=new I,k=new I,ln=new I,je=new I,Qt=new I,hn=new I,un={type:"change"},dn={type:"start"},fn={type:"end"};class ko extends Ze{get enabled(){return this._enabled}set enabled(e){e!==this.enabled&&(this._enabled=e,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(e=null,t=null,s=null,n=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=Y,this.pointerTracker=new Fo,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new b,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new b,this.zoomPoint=new b,this.zoomDelta=0,this.rotationInertiaPivot=new b,this.rotationInertia=new I,this.dragInertia=new b,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new Io,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new lr,this.raycaster.firstHitOnly=!0,this.up=new b(0,1,0),this.clock=new hr,this.fallbackPlane=new ps(new b(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=Y,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,s&&this.attach(s),t&&this.setCamera(t),e&&this.setScene(e),n&&this.setTilesRenderer(n)}setScene(e){this.scene=e}setCamera(e){this.camera=e,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=e,this.resetState()}setTilesRenderer(e){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=e,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(e){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=e,this.pointerTracker.domElement=e,e.style.touchAction="none";const t=l=>{l.preventDefault()},s=l=>{l.preventDefault();const{camera:h,raycaster:u,domElement:d,up:f,pivotMesh:p,pointerTracker:m,scene:g,pivotPoint:y,enabled:_}=this;if(m.addPointer(l),this.needsUpdate=!0,m.isPointerTouch()){if(p.visible=!1,m.getPointerCount()===0)d.setPointerCapture(l.pointerId);else if(m.getPointerCount()>2){this.resetState();return}}m.getCenterPoint(k),Re(k.x,k.y,d,k),Z(u,k,h);const A=Math.abs(u.ray.direction.dot(f));if(A<Zt||A<$t)return;const x=this._raycast(u);x&&(m.getPointerCount()===2||m.isRightClicked()||m.isLeftClicked()&&l.shiftKey?(this.setState(m.isPointerTouch()?Xt:be),y.copy(x.point),p.position.copy(x.point),p.visible=m.isPointerTouch()?!1:_,p.updateMatrixWorld(),g.add(p)):m.isLeftClicked()&&(this.setState(Ae),y.copy(x.point),p.position.copy(x.point),p.updateMatrixWorld(),g.add(p)))};let n=!1;const i=l=>{l.preventDefault();const{pivotMesh:h,enabled:u}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==Y&&(this.needsUpdate=!0);const{pointerTracker:d}=this;d.setHoverEvent(l),d.updatePointer(l)&&(d.isPointerTouch()&&d.getPointerCount()===2&&(n||(n=!0,queueMicrotask(()=>{n=!1,d.getCenterPoint(Qt);const f=d.getStartTouchPointerDistance(),p=d.getTouchPointerDistance(),m=p-f;if(this.state===Y||this.state===Xt){d.getCenterPoint(Qt),d.getStartCenterPoint(hn);const g=2*window.devicePixelRatio,y=Qt.distanceTo(hn);(Math.abs(m)>g||y>g)&&(Math.abs(m)>y?(this.setState(ve),this.zoomDirectionSet=!1):this.setState(be))}if(this.state===ve){const g=d.getPreviousTouchPointerDistance();this.zoomDelta+=p-g,h.visible=!1}else this.state===be&&(h.visible=u)}))),this.dispatchEvent(un))},r=l=>{const{pointerTracker:h}=this;h.deletePointer(l),h.getPointerType()==="touch"&&h.getPointerCount()===0&&e.releasePointerCapture(l.pointerId),this.resetState(),this.needsUpdate=!0},o=l=>{l.preventDefault();const{pointerTracker:h}=this;h.setHoverEvent(l),h.updatePointer(l),this.dispatchEvent(dn);let u;switch(l.deltaMode){case 2:u=l.deltaY*800;break;case 1:u=l.deltaY*40;break;case 0:u=l.deltaY;break}const d=Math.sign(u),f=Math.abs(u);this.zoomDelta-=.25*d*f,this.needsUpdate=!0,this._lastUsedState=ve,this.dispatchEvent(fn)},a=l=>{const{pointerTracker:h}=this;l.buttons!==h.getPointerButtons()&&(h.deletePointer(l),this.resetState())};e.addEventListener("contextmenu",t),e.addEventListener("pointerdown",s),e.addEventListener("pointermove",i),e.addEventListener("pointerup",r),e.addEventListener("wheel",o,{passive:!1}),e.addEventListener("pointerenter",a),this._detachCallback=()=>{e.removeEventListener("contextmenu",t),e.removeEventListener("pointerdown",s),e.removeEventListener("pointermove",i),e.removeEventListener("pointerup",r),e.removeEventListener("wheel",o),e.removeEventListener("pointerenter",a)}}getUpDirection(e,t){t.copy(this.up)}getCameraUpDirection(e){this.getUpDirection(this.camera.position,e)}getPivotPoint(e){let t=null;this._lastUsedState===ve?this._zoomPointWasSet&&(t=e.copy(this.zoomPoint)):(this._lastUsedState===be||this._lastUsedState===Ae)&&(t=e.copy(this.pivotPoint));const{camera:s,raycaster:n}=this;t!==null&&(D.copy(t).project(s),(D.x<-1||D.x>1||D.y<-1||D.y>1)&&(t=null)),Z(n,{x:0,y:0},s);const i=this._raycast(n);return i&&(t===null||i.distance<t.distanceTo(n.ray.origin))&&(t=e.copy(i.point)),t}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==Y&&this.dispatchEvent(fn),this.state=Y,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0}setState(e=this.state,t=!0){this.state!==e&&(this.state===Y&&t&&this.dispatchEvent(dn),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=e,e!==Y&&e!==Xt&&(this._lastUsedState=e))}update(e=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||e===0)return;const{camera:t,cameraRadius:s,pivotPoint:n,up:i,state:r,adjustHeight:o}=this;t.updateMatrixWorld(),this.getCameraUpDirection(V),this._upInitialized||(this._upInitialized=!0,this.up.copy(V));const a=this._inertiaNeedsUpdate();if(this.needsUpdate||a){const u=this.zoomDelta;this._updateZoom(),this._updatePosition(e),this._updateRotation(e),r===Ae||r===be?(Ge.set(0,0,-1).transformDirection(t.matrixWorld),this.inertiaTargetDistance=D.copy(this.pivotPoint).sub(t.position).dot(Ge)):r===Y&&this._updateInertia(e),(r!==Y||u!==0||a)&&this.dispatchEvent(un),this.needsUpdate=!1}const l=t.isOrthographicCamera?null:o&&this._getPointBelowCamera()||null,h=t.isOrthographicCamera?n:l&&l.point||null;if(this.getCameraUpDirection(V),this._setFrame(V,h),(this.state===Ae||this.state===be)&&this.actionHeightOffset!==0){const{actionHeightOffset:u}=this;t.position.addScaledVector(i,-u),n.addScaledVector(i,-u),l&&(l.distance-=u)}if(this.actionHeightOffset=0,l){const u=l.distance;if(u<s){const d=s-u;t.position.addScaledVector(i,d),n.addScaledVector(i,d),this.actionHeightOffset=d}}this.pointerTracker.updateFrame()}adjustCamera(e){const{adjustHeight:t,cameraRadius:s}=this;if(e.isPerspectiveCamera){this.getUpDirection(e.position,V);const n=t&&this._getPointBelowCamera(e.position,V)||null;if(n){const i=n.distance;i<s&&e.position.addScaledVector(V,s-i)}}}dispose(){this.detach()}_updateInertia(e){const{rotationInertia:t,pivotPoint:s,dragInertia:n,enableDamping:i,dampingFactor:r,camera:o,cameraRadius:a,minDistance:l,inertiaTargetDistance:h}=this;if(!this.enableDamping||this.inertiaStableFrames>1){n.set(0,0,0),t.set(0,0,0);return}const u=Math.pow(2,-e/r),d=Math.max(o.near,a,l,h),m=.25*(2/(2*1e3));if(t.lengthSq()>0){Z(F,D.set(0,0,-1),o),F.applyMatrix4(o.matrixWorldInverse),F.direction.normalize(),F.recast(-F.direction.dot(F.origin)).at(d/F.direction.z,D),D.applyMatrix4(o.matrixWorld),Z(F,j.set(m,m,-1),o),F.applyMatrix4(o.matrixWorldInverse),F.direction.normalize(),F.recast(-F.direction.dot(F.origin)).at(d/F.direction.z,j),j.applyMatrix4(o.matrixWorld),D.sub(s).normalize(),j.sub(s).normalize();const g=D.angleTo(j)/e;t.multiplyScalar(u),(t.lengthSq()<g**2||!i)&&t.set(0,0)}if(n.lengthSq()>0){Z(F,D.set(0,0,-1),o),F.applyMatrix4(o.matrixWorldInverse),F.direction.normalize(),F.recast(-F.direction.dot(F.origin)).at(d/F.direction.z,D),D.applyMatrix4(o.matrixWorld),Z(F,j.set(m,m,-1),o),F.applyMatrix4(o.matrixWorldInverse),F.direction.normalize(),F.recast(-F.direction.dot(F.origin)).at(d/F.direction.z,j),j.applyMatrix4(o.matrixWorld);const g=D.distanceTo(j)/e;n.multiplyScalar(u),(n.lengthSq()<g**2||!i)&&n.set(0,0,0)}t.lengthSq()>0&&this._applyRotation(t.x*e,t.y*e,s),n.lengthSq()>0&&(o.position.addScaledVector(n,e),o.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:e,dragInertia:t}=this;return e.lengthSq()!==0||t.lengthSq()!==0}_updateZoom(){const{zoomPoint:e,zoomDirection:t,camera:s,minDistance:n,maxDistance:i,pointerTracker:r,domElement:o,minZoom:a,maxZoom:l,zoomSpeed:h,state:u}=this;let d=this.zoomDelta;if(this.zoomDelta=0,!(!r.getLatestPoint(k)||d===0&&u!==ve))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),s.isOrthographicCamera){this._updateZoomDirection();const f=this.zoomPointSet||this._updateZoomPoint();pt.unproject(s);const p=Math.pow(.95,Math.abs(d*.05));let m=d>0?1/Math.abs(p):p;m*=h,m>1?l<s.zoom*m&&(m=1):a>s.zoom*m&&(m=1),s.zoom*=m,s.updateProjectionMatrix(),f&&(Re(k.x,k.y,o,Yt),Yt.unproject(s),s.position.sub(Yt).add(pt),s.updateMatrixWorld())}else{this._updateZoomDirection();const f=D.copy(t);if(this.zoomPointSet||this._updateZoomPoint()){const p=e.distanceTo(s.position);if(d<0){const m=Math.min(0,p-i);d=d*p*h*.0025,d=Math.max(d,m)}else{const m=Math.max(0,p-n);d=d*Math.max(p-n,0)*h*.0025,d=Math.min(d,m)}s.position.addScaledVector(t,d),s.updateMatrixWorld()}else{const p=this._getPointBelowCamera();if(p){const m=p.distance;f.set(0,0,-1).transformDirection(s.matrixWorld),s.position.addScaledVector(f,d*m*.01),s.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:e,raycaster:t,camera:s,zoomDirection:n,pointerTracker:i}=this;i.getLatestPoint(k),Re(k.x,k.y,e,pt),Z(t,pt,s),n.copy(t.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:e,zoomDirectionSet:t,zoomDirection:s,raycaster:n,zoomPoint:i,pointerTracker:r,domElement:o}=this;if(this._zoomPointWasSet=!1,!t)return!1;e.isOrthographicCamera&&r.getLatestPoint(He)?(Re(He.x,He.y,o,He),Z(n,He,e)):(n.ray.origin.copy(e.position),n.ray.direction.copy(s),n.near=0,n.far=1/0);const a=this._raycast(n);return a?(i.copy(a.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(e=this.camera.position,t=this.up){const{raycaster:s}=this;s.ray.direction.copy(t).multiplyScalar(-1),s.ray.origin.copy(e).addScaledVector(t,1e5),s.near=0,s.far=1/0;const n=this._raycast(s);return n&&(n.distance-=1e5),n}_updatePosition(e){const{raycaster:t,camera:s,pivotPoint:n,up:i,pointerTracker:r,domElement:o,state:a,dragInertia:l}=this;if(a===Ae){if(r.getCenterPoint(k),Re(k.x,k.y,o,k),cn.setFromNormalAndCoplanarPoint(i,n),Z(t,k,s),Math.abs(t.ray.direction.dot(i))<Zt){const h=Math.acos(Zt);Ce.crossVectors(t.ray.direction,i).normalize(),t.ray.direction.copy(i).applyAxisAngle(Ce,h).multiplyScalar(-1)}if(this.getUpDirection(n,V),Math.abs(t.ray.direction.dot(V))<$t){const h=Math.acos($t);Ce.crossVectors(t.ray.direction,V).normalize(),t.ray.direction.copy(V).applyAxisAngle(Ce,h).multiplyScalar(-1)}t.ray.intersectPlane(cn,D)&&(j.subVectors(n,D),s.position.add(j),s.updateMatrixWorld(),j.multiplyScalar(1/e),r.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(j),this.inertiaStableFrames=0))}}_updateRotation(e){const{pivotPoint:t,pointerTracker:s,domElement:n,state:i,rotationInertia:r}=this;i===be&&(s.getCenterPoint(k),s.getPreviousCenterPoint(ln),je.subVectors(k,ln).multiplyScalar(2*Math.PI/n.clientHeight),this._applyRotation(je.x,je.y,t),je.multiplyScalar(1/e),s.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(r.copy(je),this.inertiaStableFrames=0))}_applyRotation(e,t,s){if(e===0&&t===0)return;const{camera:n,minAltitude:i,maxAltitude:r,rotationSpeed:o}=this,a=-e*o;let l=t*o;Ge.set(0,0,1).transformDirection(n.matrixWorld),this.getUpDirection(s,V),D.crossVectors(V,Ge).normalize(),an.set(1,0,0).transformDirection(n.matrixWorld).normalize();const u=Math.sign(D.dot(an))*V.angleTo(Ge);l>0?(l=Math.min(u-i-.01,l),l=Math.max(0,l)):(l=Math.max(u-r,l),l=Math.min(0,l)),fe.setFromAxisAngle(V,a),we(s,fe,de),n.matrixWorld.premultiply(de),Ce.set(-1,0,0).transformDirection(n.matrixWorld),fe.setFromAxisAngle(Ce,l),we(s,fe,de),n.matrixWorld.premultiply(de),n.matrixWorld.decompose(n.position,n.quaternion,D)}_setFrame(e,t){const{up:s,camera:n,state:i,zoomPoint:r,zoomDirectionSet:o,zoomPointSet:a,reorientOnDrag:l,scaleZoomOrientationAtEdges:h}=this;n.updateMatrixWorld(),fe.setFromUnitVectors(s,e);const u=i;if(o&&(a||this._updateZoomPoint())){if(this.getUpDirection(r,D),h){let d=Math.max(D.dot(s)-.6,0)/.4;d=v.mapLinear(d,0,.5,0,1),d=Math.min(d,1),n.isOrthographicCamera&&(d*=.1),fe.slerp(No,1-d)}we(r,fe,de),n.matrixWorld.premultiply(de),n.matrixWorld.decompose(n.position,n.quaternion,D),this.zoomDirectionSet=!1,this._updateZoomDirection()}else u===Ae&&l&&t&&(we(t,fe,de),n.matrixWorld.premultiply(de),n.matrixWorld.decompose(n.position,n.quaternion,D));s.copy(e),n.updateMatrixWorld()}_raycast(e){const{scene:t,useFallbackPlane:s,fallbackPlane:n}=this,i=e.intersectObject(t)[0]||null;if(i)return i;if(s){const r=n;if(e.ray.intersectPlane(r,D))return{point:D.clone(),distance:e.ray.origin.distanceTo(D)}}return null}}const pn=new L,Pe=new L,K=new b,R=new b,re=new b,B=new b,Jt=new b,mt=new b,mn=new b,$=new ee,gn=new b,xe=new b,O=new Se,es=new _s,yn={},We=new I,Uo=400;class Bo extends ko{get ellipsoid(){return this.tilesRenderer?this.tilesRenderer.ellipsoid:null}get tilesGroup(){return this.tilesRenderer?this.tilesRenderer.group:null}constructor(e=null,t=null,s=null,n=null){super(e,t,s),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.reorientOnDrag=!1,this.globeInertia=new ee,this.globeInertiaFactor=0,this.setTilesRenderer(n)}setScene(e){e===null&&this.tilesRenderer!==null?super.setScene(this.tilesRenderer.group):super.setScene(e)}getPivotPoint(e){const{camera:t,tilesGroup:s,ellipsoid:n}=this;return B.set(0,0,-1).transformDirection(t.matrixWorld),O.origin.copy(t.position),O.direction.copy(B),O.applyMatrix4(s.matrixWorldInverse),Kt(O,n,R),R.applyMatrix4(s.matrixWorld),(super.getPivotPoint(e)===null||e.distanceTo(O.origin)>R.distanceTo(O.origin))&&e.copy(R),e}getVectorToCenter(e){const{tilesGroup:t,camera:s}=this;return e.setFromMatrixPosition(t.matrixWorld).sub(s.position)}getDistanceToCenter(){return this.getVectorToCenter(R).length()}getUpDirection(e,t){const{tilesGroup:s,ellipsoid:n}=this;R.copy(e).applyMatrix4(s.matrixWorldInverse),n.getPositionToNormal(R,t),t.transformDirection(s.matrixWorld)}getCameraUpDirection(e){const{tilesGroup:t,ellipsoid:s,camera:n}=this;n.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(R),R.applyMatrix4(t.matrixWorldInverse),s.getPositionToNormal(R,e),e.transformDirection(t.matrixWorld)):this.getUpDirection(n.position,e)}update(e=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.tilesGroup||!this.camera||e===0)return;const{camera:t,pivotMesh:s}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(this.state!==Y&&this._dragMode!==1&&this._rotationMode!==1&&(s.visible=!1),this.scaleZoomOrientationAtEdges=!1),super.update(e),this.adjustCamera(t)}adjustCamera(e){super.adjustCamera(e);const{tilesGroup:t,ellipsoid:s,nearMargin:n,farMargin:i}=this,r=Math.max(...s.radius);if(e.isPerspectiveCamera){const o=R.setFromMatrixPosition(t.matrixWorld).sub(e.position).length(),a=n*r,l=v.clamp((o-r)/a,0,1),h=v.lerp(1,1e3,l);e.near=Math.max(h,o-r-a),K.copy(e.position).applyMatrix4(t.matrixWorldInverse),s.getPositionToCartographic(K,yn);const u=Math.max(s.getPositionElevation(K),Uo),d=s.calculateHorizonDistance(yn.lat,u);e.far=d*2.5+.1+r*i,e.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(e.position,e),e.updateMatrixWorld(),pn.copy(e.matrixWorld).invert(),R.setFromMatrixPosition(t.matrixWorld).applyMatrix4(pn);const o=-R.z;e.near=o-r*(1+n),e.far=o+.1+r*i,e.position.addScaledVector(B,e.near),e.far-=e.near,e.near=0,e.updateProjectionMatrix(),e.updateMatrixWorld()}}resetState(){super.resetState(),this._dragMode=0,this._rotationMode=0}_updateInertia(e){super._updateInertia(e);const{globeInertia:t,enableDamping:s,dampingFactor:n,camera:i,cameraRadius:r,minDistance:o,inertiaTargetDistance:a,tilesGroup:l}=this;if(!this.enableDamping||this.inertiaStableFrames>1){this.globeInertiaFactor=0,this.globeInertia.identity();return}const h=Math.pow(2,-e/n),u=Math.max(i.near,r,o,a),p=.25*(2/(2*1e3));if(re.setFromMatrixPosition(l.matrixWorld),this.globeInertiaFactor!==0){Z(O,R.set(0,0,-1),i),O.applyMatrix4(i.matrixWorldInverse),O.direction.normalize(),O.recast(-O.direction.dot(O.origin)).at(u/O.direction.z,R),R.applyMatrix4(i.matrixWorld),Z(O,K.set(p,p,-1),i),O.applyMatrix4(i.matrixWorldInverse),O.direction.normalize(),O.recast(-O.direction.dot(O.origin)).at(u/O.direction.z,K),K.applyMatrix4(i.matrixWorld),R.sub(re).normalize(),K.sub(re).normalize(),this.globeInertiaFactor*=h;const m=R.angleTo(K)/e;(2*Math.acos(t.w)*this.globeInertiaFactor<m||!s)&&(this.globeInertiaFactor=0,t.identity())}this.globeInertiaFactor!==0&&(t.w===1&&(t.x!==0||t.y!==0||t.z!==0)&&(t.w=Math.min(t.w,1-1e-9)),re.setFromMatrixPosition(l.matrixWorld),$.identity().slerp(t,this.globeInertiaFactor*e),we(re,$,Pe),i.matrixWorld.premultiply(Pe),i.matrixWorld.decompose(i.position,i.quaternion,R))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||this.globeInertiaFactor!==0}_updatePosition(e){if(this.state===Ae){this._dragMode===0&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:t,camera:s,pivotPoint:n,pointerTracker:i,domElement:r,tilesGroup:o}=this,a=K,l=mt;i.getCenterPoint(We),Re(We.x,We.y,r,We),Z(t,We,s),t.ray.applyMatrix4(o.matrixWorldInverse);const h=R.copy(n).applyMatrix4(o.matrixWorldInverse).length();es.radius.setScalar(h),s.isPerspectiveCamera?es.intersectRay(t.ray,R)||Oo(t.ray,h,R):Kt(t.ray,es,R),R.applyMatrix4(o.matrixWorld),re.setFromMatrixPosition(o.matrixWorld),a.subVectors(n,re).normalize(),l.subVectors(R,re).normalize(),$.setFromUnitVectors(l,a),we(re,$,Pe),s.matrixWorld.premultiply(Pe),s.matrixWorld.decompose(s.position,s.quaternion,R),i.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy($),this.globeInertiaFactor=1/e,this.inertiaStableFrames=0)}this._alignCameraUp(this.up)}_updateRotation(...e){this._rotationMode===1||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...e)):(this.pivotMesh.visible=!1,this._rotationMode=-1),this._alignCameraUp(this.up)}_updateZoom(){const{zoomDelta:e,ellipsoid:t,zoomSpeed:s,zoomPoint:n,camera:i,maxZoom:r,state:o}=this;if(o!==ve&&e===0)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const a=v.clamp(v.mapLinear(Math.abs(e),0,20,0,1),0,1);if(this._isNearControls()||e>0){if(this._updateZoomDirection(),e<0&&(this.zoomPointSet||this._updateZoomPoint())){B.set(0,0,-1).transformDirection(i.matrixWorld).normalize(),xe.copy(this.up).multiplyScalar(-1),this.getUpDirection(n,gn);const l=v.clamp(v.mapLinear(-gn.dot(xe),1,.95,0,1),0,1),h=1-B.dot(xe),u=i.isOrthographicCamera?.05:1,d=v.clamp(a*3,0,1),f=Math.min(l*h*u*d,.1);xe.lerpVectors(B,xe,f).normalize(),$.setFromUnitVectors(B,xe),we(n,$,Pe),i.matrixWorld.premultiply(Pe),i.matrixWorld.decompose(i.position,i.quaternion,xe),this.zoomDirection.subVectors(n,i.position).normalize()}super._updateZoom()}else if(i.isPerspectiveCamera){const l=this._getPerspectiveTransitionDistance(),h=this._getMaxPerspectiveDistance(),u=v.mapLinear(this.getDistanceToCenter(),l,h,0,1);this._tiltTowardsCenter(v.lerp(0,.4,u*a)),this._alignCameraUpToNorth(v.lerp(0,.2,u*a));const d=this.getDistanceToCenter()-t.radius.x,f=e*d*s*.0025,p=Math.max(f,Math.min(this.getDistanceToCenter()-h,0));this.getVectorToCenter(R).normalize(),this.camera.position.addScaledVector(R,p),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const l=this._getOrthographicTransitionZoom(),h=this._getMinOrthographicZoom(),u=v.mapLinear(i.zoom,l,h,0,1);this._tiltTowardsCenter(v.lerp(0,.4,u*a)),this._alignCameraUpToNorth(v.lerp(0,.2,u*a));const d=this.zoomDelta,f=Math.pow(.95,Math.abs(d*.05)),p=d>0?1/Math.abs(f):f,m=h/i.zoom,g=Math.max(p*s,Math.min(m,1));i.zoom=Math.min(r,i.zoom*g),i.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(e){const{tilesGroup:t}=this;mn.set(0,0,1).transformDirection(t.matrixWorld),this._alignCameraUp(mn,e)}_alignCameraUp(e,t=null){const{camera:s}=this;B.set(0,0,-1).transformDirection(s.matrixWorld),Jt.set(-1,0,0).transformDirection(s.matrixWorld),mt.crossVectors(e,B),t===null&&(t=1-Math.abs(B.dot(e)),t=v.mapLinear(t,0,1,-.01,1),t=v.clamp(t,0,1)**2),mt.lerp(Jt,1-t).normalize(),$.setFromUnitVectors(Jt,mt),s.quaternion.premultiply($),s.updateMatrixWorld()}_tiltTowardsCenter(e){const{camera:t,tilesGroup:s}=this;B.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),R.setFromMatrixPosition(s.matrixWorld).sub(t.position).normalize(),R.lerp(B,1-e).normalize(),$.setFromUnitVectors(B,R),t.quaternion.premultiply($),t.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const s=Math.max(...t.radius),n=2*Math.atan(Math.tan(v.DEG2RAD*e.fov*.5)*e.aspect),i=s/Math.tan(v.DEG2RAD*e.fov*.5),r=s/Math.tan(n*.5);return Math.max(i,r)}_getMaxPerspectiveDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const s=Math.max(...t.radius),n=2*Math.atan(Math.tan(v.DEG2RAD*e.fov*.5)*e.aspect),i=s/Math.tan(v.DEG2RAD*e.fov*.5),r=s/Math.tan(n*.5);return 2*Math.max(i,r)}_getOrthographicTransitionZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const s=e.top-e.bottom,n=e.right-e.left,i=Math.max(s,n),o=2*Math.max(...t.radius);return 2*i/o}_getMinOrthographicZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const s=e.top-e.bottom,n=e.right-e.left,i=Math.min(s,n),o=2*Math.max(...t.radius);return .7*i/o}_getVirtualOrthoCameraPosition(e,t=this.camera){const{tilesGroup:s,ellipsoid:n}=this;if(!t.isOrthographicCamera)throw new Error;O.origin.copy(t.position),O.direction.set(0,0,-1).transformDirection(t.matrixWorld),O.applyMatrix4(s.matrixWorldInverse),Kt(O,n,K),K.applyMatrix4(s.matrixWorld);const i=t.top-t.bottom,r=t.right-t.left,o=Math.max(i,r)/t.zoom;B.set(0,0,-1).transformDirection(t.matrixWorld);const a=K.sub(t.position).dot(B);e.copy(t.position).addScaledVector(B,a-o*4)}_isNearControls(){const{camera:e}=this;return e.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():e.zoom>this._getOrthographicTransitionZoom()}_raycast(e){const t=super._raycast(e);if(t===null){const{ellipsoid:s,tilesGroup:n}=this;O.copy(e.ray).applyMatrix4(n.matrixWorldInverse);const i=s.intersectRay(O,R);return i!==null?{point:i.clone().applyMatrix4(n.matrixWorld)}:null}else return t}}class Vo{constructor(){this.creditsCount={}}_adjustAttributions(e,t){const s=this.creditsCount,n=e.split(/;/g);for(let i=0,r=n.length;i<r;i++){const o=n[i];o in s||(s[o]=0),s[o]+=t?1:-1,s[o]<=0&&delete s[o]}}addAttributions(e){this._adjustAttributions(e,!0)}removeAttributions(e){this._adjustAttributions(e,!1)}toString(){return Object.entries(this.creditsCount).sort((t,s)=>{const n=t[1];return s[1]-n}).map(t=>t[0]).join("; ")}}function _n(c){let e=null;return ii(c,t=>{if(t.content&&t.content.uri){const[,s]=t.content.uri.split("?");return e=new URLSearchParams(s).get("session"),!0}return!1}),e}class zo{constructor({apiToken:e,autoRefreshToken:t=!1,logoUrl:s=null,useRecommendedSettings:n=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.priority=-1/0,this.apiToken=e,this.autoRefreshToken=t,this.useRecommendedSettings=n,this.logoUrl=s,this.sessionToken=null,this.tiles=null,this._onLoadCallback=null,this._visibilityChangeCallback=null,this._tokenRefreshPromise=null,this._attributionsManager=new Vo,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(e){e!=null&&(e.resetFailedTiles(),e.rootURL==null&&(e.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),this.useRecommendedSettings&&(e.parseQueue.maxJobs=10,e.downloadQueue.maxJobs=30,e.errorTarget=40),this.tiles=e,this._onLoadCallback=({tileSet:t})=>{this.sessionToken=_n(t.root),e.removeEventListener("load-tile-set",this._onLoadCallback)},this._visibilityChangeCallback=({tile:t,visible:s})=>{const n=t.cached.metadata.asset.copyright||"";s?this._attributionsManager.addAttributions(n):this._attributionsManager.removeAttributions(n)},e.addEventListener("load-tile-set",this._onLoadCallback),e.addEventListener("tile-visibility-change",this._visibilityChangeCallback))}getAttributions(e){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,e.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),e.push(this._attribution))}preprocessURL(e){return e=new URL(e),/^http/.test(e.protocol)&&(e.searchParams.append("key",this.apiToken),this.sessionToken!==null&&e.searchParams.append("session",this.sessionToken)),e.toString()}dispose(){const{tiles:e}=this;e.removeEventListener("load-tile-set",this._onLoadCallback),e.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(e,t){this._tokenRefreshPromise!==null&&(await this._tokenRefreshPromise,e=this.preprocessURL(e));const s=await fetch(e,t);return s.status>=400&&s.status<=499&&this.autoRefreshToken?(await this._refreshToken(t),fetch(this.preprocessURL(e),t)):s}_refreshToken(e){if(this._tokenRefreshPromise===null){const t=new URL(this.tiles.rootURL);t.searchParams.append("key",this.apiToken),this._tokenRefreshPromise=fetch(t,e).then(s=>s.json()).then(s=>{this.sessionToken=_n(s.root),this._tokenRefreshPromise=null}),this._tokenRefreshPromise.catch(s=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:s,rootURL:t})})}return this._tokenRefreshPromise}}const ts=new L;class Go{constructor(){this.name="UPDATE_ON_CHANGE_PLUGIN",this.tiles=null,this.needsUpdate=!1,this.cameraMatrices=new Map}init(e){this.tiles=e,this._needsUpdateCallback=()=>{this.needsUpdate=!0},this._onCameraAdd=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.set(t,new L)},this._onCameraDelete=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.delete(t)},e.addEventListener("camera-resolution-change",this._needsUpdateCallback),e.addEventListener("load-content",this._needsUpdateCallback),e.addEventListener("add-camera",this._onCameraAdd),e.addEventListener("delete-camera",this._onCameraDelete),e.cameras.forEach(t=>{this._onCameraAdd({camera:t})})}doTilesNeedUpdate(){const e=this.tiles;let t=!1;this.cameraMatrices.forEach((n,i)=>{ts.copy(e.group.matrixWorld).premultiply(i.matrixWorldInverse).premultiply(i.projectionMatrixInverse),t=t||!ts.equals(n),n.copy(ts)});const s=this.needsUpdate;return this.needsUpdate=!1,s||t}preprocessNode(){this.needsUpdate=!0}dispose(){const e=this.tiles;e.removeEventListener("camera-resolution-change",this._needsUpdateCallback),e.removeEventListener("load-content",this._needsUpdateCallback),e.removeEventListener("camera-add",this._onCameraAdd),e.removeEventListener("camera-delete",this._onCameraDelete)}}const Tn=new b;function qe(c,e){if(c.isInterleavedBufferAttribute||c.array instanceof e)return c;const s=e===Int8Array||e===Int16Array||e===Int32Array?-1:0,n=new e(c.count*c.itemSize),i=new z(n,c.itemSize,!0),r=c.itemSize,o=c.count;for(let a=0;a<o;a++)for(let l=0;l<r;l++){const h=v.clamp(c.getComponent(a,l),s,1);i.setComponent(a,l,h)}return i}function Ho(c,e=Int16Array){const t=c.geometry,s=t.attributes,n=s.position;if(n.isInterleavedBufferAttribute||n.array instanceof e)return n;const i=new e(n.count*n.itemSize),r=new z(i,n.itemSize,!1),o=n.itemSize,a=n.count;t.computeBoundingBox();const l=t.boundingBox,{min:h,max:u}=l,d=2**(8*e.BYTES_PER_ELEMENT-1)-1,f=-d;for(let p=0;p<a;p++)for(let m=0;m<o;m++){const g=m===0?"x":m===1?"y":"z",y=h[g],_=u[g],A=v.mapLinear(n.getComponent(p,m),y,_,f,d);r.setComponent(p,m,A)}l.getCenter(Tn),c.position.add(Tn),c.scale.x*=.5*(u.x-h.x)/d,c.scale.y*=.5*(u.y-h.y)/d,c.scale.z*=.5*(u.z-h.z)/d,s.position=r,c.geometry.boundingBox=null,c.geometry.boundingSphere=null,c.updateMatrixWorld()}class jo{constructor(e){this._options={generateNormals:!1,disableMipmaps:!0,compressIndex:!0,compressNormals:!1,compressUvs:!1,compressPosition:!1,uvType:Int8Array,normalType:Int8Array,positionType:Int16Array,...e},this.name="TILES_COMPRESSION_PLUGIN",this.priority=-100}processTileModel(e,t){const{generateNormals:s,disableMipmaps:n,compressIndex:i,compressUvs:r,compressNormals:o,compressPosition:a,uvType:l,normalType:h,positionType:u}=this._options;e.traverse(d=>{if(d.material&&n){const f=d.material;for(const p in f){const m=f[p];m&&m.isTexture&&m.generateMipmaps&&(m.generateMipmaps=!1,m.minFilter=gt)}}if(d.geometry){const f=d.geometry,p=f.attributes;if(r){const{uv:m,uv1:g,uv2:y,uv3:_}=p;m&&(p.uv=qe(m,l)),g&&(p.uv1=qe(g,l)),y&&(p.uv2=qe(y,l)),_&&(p.uv3=qe(_,l))}if(s&&!p.normals&&f.computeVertexNormals(),o&&p.normals&&(p.normals=qe(p.normals,h)),a&&Ho(d,u),i&&f.index){const m=p.position.count,g=f.index,y=m>65535?Uint32Array:m>255?Uint16Array:Uint8Array;if(!(g.array instanceof y)){const _=new y(f.index.count);_.set(g.array);const A=new z(_,1);f.setIndex(A)}}}})}}function U(c,e,t){return c&&e in c?c[e]:t}function wi(c){return c!=="BOOLEAN"&&c!=="STRING"&&c!=="ENUM"}function Wo(c){return/^FLOAT/.test(c)}function tt(c){return/^VEC/.test(c)}function st(c){return/^MAT/.test(c)}function Si(c,e,t,s=null){return st(t)||tt(t)?s.fromArray(c,e):c[e]}function us(c){const{type:e,componentType:t}=c;switch(e){case"SCALAR":return t==="INT64"?0n:0;case"VEC2":return new I;case"VEC3":return new b;case"VEC4":return new dr;case"MAT2":return new ur;case"MAT3":return new Qn;case"MAT4":return new L;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function bn(c,e){if(e==null)return!1;switch(c){case"SCALAR":return typeof e=="number"||typeof e=="bigint";case"VEC2":return e.isVector2;case"VEC3":return e.isVector3;case"VEC4":return e.isVector4;case"MAT2":return e.isMatrix2;case"MAT3":return e.isMatrix3;case"MAT4":return e.isMatrix4;case"BOOLEAN":return typeof e=="boolean";case"STRING":return typeof e=="string";case"ENUM":return typeof e=="number"||typeof e=="bigint"}throw new Error("ClassProperty: invalid type.")}function et(c,e=null){switch(c){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(e){case"BOOLEAN":return Uint8Array;case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function qo(c,e=null){if(c.array){e=e&&Array.isArray(e)?e:[],e.length=c.count;for(let s=0,n=e.length;s<n;s++)e[s]=yt(c,e[s])}else e=yt(c,e);return e}function yt(c,e=null){const t=c.default,s=c.type;if(e=e||us(c),t===null){switch(s){case"SCALAR":return 0;case"VEC2":return e.set(0,0);case"VEC3":return e.set(0,0,0);case"VEC4":return e.set(0,0,0,0);case"MAT2":return e.identity();case"MAT3":return e.identity();case"MAT4":return e.identity();case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}else if(st(s))e.fromArray(t);else if(tt(s))e.fromArray(t);else return t}function Ko(c,e){if(c.noData===null)return e;const t=c.noData,s=c.type;if(Array.isArray(e))for(let r=0,o=e.length;r<o;r++)e[r]=n(e[r]);else e=n(e);return e;function n(r){return i(r)&&(r=yt(c,r)),r}function i(r){if(st(s)){const o=r.elements;for(let a=0,l=t.length;a<l;a++)if(t[a]!==o[a])return!1;return!0}else if(tt(s)){for(let o=0,a=t.length;o<a;o++)if(t[o]!==r.getComponent(o))return!1;return!0}else return t===r}}function Xo(c,e){switch(c){case"INT8":return Math.max(e/127,-1);case"INT16":return Math.max(e,32767,-1);case"INT32":return Math.max(e/2147483647,-1);case"INT64":return Math.max(Number(e)/9223372036854776e3,-1);case"UINT8":return e/255;case"UINT16":return e/65535;case"UINT32":return e/4294967295;case"UINT64":return Number(e)/18446744073709552e3}}function Zo(c,e){const{type:t,componentType:s,scale:n,offset:i,normalized:r}=c;if(Array.isArray(e))for(let u=0,d=e.length;u<d;u++)e[u]=o(e[u]);else e=o(e);return e;function o(u){return st(t)?u=l(u):tt(t)?u=a(u):u=h(u),u}function a(u){return u.x=h(u.x),u.y=h(u.y),"z"in u&&(u.z=h(u.z)),"w"in u&&(u.w=h(u.w)),u}function l(u){const d=u.elements;for(let f=0,p=d.length;f<p;f++)d[f]=h(d[f]);return u}function h(u){return r&&(u=Xo(s,u)),(r||Wo(s))&&(u=u*n+i),u}}function Ts(c,e,t=null){if(c.array){Array.isArray(e)||(e=new Array(c.count||0)),e.length=t!==null?t:c.count;for(let s=0,n=e.length;s<n;s++)bn(c.type,e[s])||(e[s]=us(c))}else bn(c.type,e)||(e=us(c));return e}function _t(c,e){for(const t in e)t in c||delete e[t];for(const t in c){const s=c[t];e[t]=Ts(s,e[t])}}function $o(c){switch(c){case"ENUM":return 1;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;case"BOOLEAN":return-1;case"STRING":return-1;default:return-1}}class Mt{constructor(e,t,s=null){this.name=t.name||null,this.description=t.description||null,this.type=t.type,this.componentType=t.componentType||null,this.enumType=t.enumType||null,this.array=t.array||!1,this.count=t.count||0,this.normalized=t.normalized||!1,this.offset=t.offset||0,this.scale=U(t,"scale",1),this.max=U(t,"max",1/0),this.min=U(t,"min",-1/0),this.required=t.required||!1,this.noData=U(t,"noData",null),this.default=U(t,"default",null),this.semantic=U(t,"semantic",null),this.enumSet=null,this.accessorProperty=s,s&&(this.offset=U(s,"offset",this.offset),this.scale=U(s,"scale",this.scale),this.max=U(s,"max",this.max),this.min=U(s,"min",this.min)),t.type==="ENUM"&&(this.enumSet=e[this.enumType],this.componentType===null&&(this.componentType=U(this.enumSet,"valueType","UINT16")))}shapeToProperty(e,t=null){return Ts(this,e,t)}resolveDefaultElement(e){return yt(this,e)}resolveDefault(e){return qo(this,e)}resolveNoData(e){return Ko(this,e)}resolveEnumsToStrings(e){const t=this.enumSet;if(this.type==="ENUM")if(Array.isArray(e))for(let n=0,i=e.length;n<i;n++)e[n]=s(e[n]);else e=s(e);return e;function s(n){const i=t.values.find(r=>r.value===n);return i===null?"":i.name}}adjustValueScaleOffset(e){return wi(this.type)?Zo(this,e):e}}class bs{constructor(e,t={},s={},n=null){this.definition=e,this.class=t[e.class],this.className=e.class,this.enums=s,this.data=n,this.name="name"in e?e.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(e){return!!this.definition.properties[e]}dispose(){}_initProperties(e=Mt){const t={};for(const s in this.class.properties)t[s]=new e(this.enums,this.class.properties[s],this.definition.properties[s]);this.properties=t}}class Yo extends Mt{constructor(e,t,s=null){super(e,t,s),this.attribute=s.attribute}}class Qo extends bs{constructor(...e){super(...e),this.isPropertyAttributeAccessor=!0,this._initProperties(Yo)}getData(e,t,s={}){const n=this.properties;_t(n,s);for(const i in n)s[i]=this.getPropertyValue(i,e,t,s[i]);return s}getPropertyValue(e,t,s,n=null){if(t>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const i=this.properties[e],r=i.type;if(i){if(!this.definition.properties[e])return i.resolveDefault(n)}else throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");n=i.shapeToProperty(n);const o=s.getAttribute(i.attribute.toLowerCase());if(st(r)){const a=n.elements;for(let l=0,h=a.length;l<h;l<h)a[l]=o.getComponent(t,l)}else if(tt(r))n.fromBufferAttribute(o,t);else if(r==="SCALAR"||r==="ENUM")n=o.getX(t);else throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");return n=i.adjustValueScaleOffset(n),n=i.resolveEnumsToStrings(n),n=i.resolveNoData(n),n}}class Jo extends Mt{constructor(e,t,s=null){super(e,t,s),this.values=s.values,this.valueLength=$o(this.type),this.arrayOffsets=U(s,"arrayOffsets",null),this.stringOffsets=U(s,"stringOffsets",null),this.arrayOffsetType=U(s,"arrayOffsetType","UINT32"),this.stringOffsetType=U(s,"stringOffsetType","UINT32")}getArrayLengthFromId(e,t){let s=this.count;if(this.arrayOffsets!==null){const{arrayOffsets:n,arrayOffsetType:i}=this,r=et(i),o=new r(e[n]);s=o[t+1]-o[t]}return s}getIndexOffsetFromId(e,t){let s=t;if(this.arrayOffsets){const{arrayOffsets:n,arrayOffsetType:i}=this,r=et(i);s=new r(e[n])[s]}else this.array&&(s*=this.count);return s}}class ea extends bs{constructor(...e){super(...e),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(Jo)}getData(e,t={}){const s=this.properties;_t(s,t);for(const n in s)t[n]=this.getPropertyValue(n,e,t[n]);return t}_readValueAtIndex(e,t,s,n=null){const i=this.properties[e],{componentType:r,type:o}=i,a=this.data,l=a[i.values],h=et(r,o),u=new h(l),d=i.getIndexOffsetFromId(a,t);if(wi(o)||o==="ENUM")return Si(u,(d+s)*i.valueLength,o,n);if(o==="STRING"){let f=d+s,p=0;if(i.stringOffsets!==null){const{stringOffsets:g,stringOffsetType:y}=i,_=et(y),A=new _(a[g]);p=A[f+1]-A[f],f=A[f]}const m=new Uint8Array(u.buffer,f,p);n=new TextDecoder().decode(m)}else if(o==="BOOLEAN"){const f=d+s,p=Math.floor(f/8),m=f%8;n=(u[p]>>m&1)===1}return n}getPropertyValue(e,t,s=null){if(t>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const n=this.properties[e];if(n){if(!this.definition.properties[e])return n.resolveDefault(s)}else throw new Error("PropertyTableAccessor: Requested property does not exist.");const i=n.array,r=this.data,o=n.getArrayLengthFromId(r,t);if(s=n.shapeToProperty(s,o),i)for(let a=0,l=s.length;a<l;a++)s[a]=this._readValueAtIndex(e,t,a,s[a]);else s=this._readValueAtIndex(e,t,0,s);return s=n.adjustValueScaleOffset(s),s=n.resolveEnumsToStrings(s),s=n.resolveNoData(s),s}}const ta=new Xn(-1,1,1,-1,0,1);class sa extends bt{constructor(){super(),this.setAttribute("position",new Ms([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Ms([0,2,0,0,2,0],2))}}const na=new sa;class ia{constructor(e){this._mesh=new ds(na,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,ta)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}const Ke=new yr;class xn{constructor(){this._renderer=new fr,this._target=new Cs(1,1),this._texTarget=new Cs,this._quad=new ia(new Jn({blending:gr,blendDst:mr,blendSrc:pr,uniforms:{map:{value:null},pixel:{value:new I}},vertexShader:`
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,fragmentShader:`
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`}))}increaseSizeTo(e){this._target.setSize(Math.max(this._target.width,e),1)}readDataAsync(e){const{_renderer:t,_target:s}=this;return t.readRenderTargetPixelsAsync(s,0,0,e.length/4,1,e)}readData(e){const{_renderer:t,_target:s}=this;t.readRenderTargetPixels(s,0,0,e.length/4,1,e)}renderPixelToTarget(e,t,s){const{_renderer:n,_target:i}=this;Ke.min.copy(t),Ke.max.copy(t),Ke.max.x+=1,Ke.max.y+=1,n.initRenderTarget(i),n.copyTextureToTexture(e,i.texture,Ke,s,0)}}const ge=new class{constructor(){let c=null;Object.getOwnPropertyNames(xn.prototype).forEach(e=>{e!=="constructor"&&(this[e]=(...t)=>(c=c||new xn,c[e](...t)))})}},An=new I,wn=new I,Sn=new I;function ra(c,e){return e===0?c.getAttribute("uv"):c.getAttribute(`uv${e}`)}function Ei(c,e,t=new Array(3)){let s=3*e,n=3*e+1,i=3*e+2;return c.index&&(s=c.index.getX(s),n=c.index.getX(n),i=c.index.getX(i)),t[0]=s,t[1]=n,t[2]=i,t}function Mi(c,e,t,s,n){const[i,r,o]=s,a=ra(c,e);An.fromBufferAttribute(a,i),wn.fromBufferAttribute(a,r),Sn.fromBufferAttribute(a,o),n.set(0,0,0).addScaledVector(An,t.x).addScaledVector(wn,t.y).addScaledVector(Sn,t.z)}function Ci(c,e,t,s){const n=c.x-Math.floor(c.x),i=c.y-Math.floor(c.y),r=Math.floor(n*e%e),o=Math.floor(i*t%t);return s.set(r,o),s}const En=new I,Mn=new I,Cn=new I;class oa extends Mt{constructor(e,t,s=null){super(e,t,s),this.channels=U(s,"channels",[0]),this.index=U(s,"index",null),this.texCoord=U(s,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(e,t,s=null){const n=this.type;if(n==="BOOLEAN"||n==="STRING")throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return Si(e,t*this.valueLength,n,s)}}class aa extends bs{constructor(...e){super(...e),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(oa)}getData(e,t,s,n={}){const i=this.properties;_t(i,n);const r=Object.keys(i),o=r.map(a=>n[a]);return this.getPropertyValuesAtTexel(r,e,t,s,o),r.forEach((a,l)=>n[a]=o[l]),n}async getDataAsync(e,t,s,n={}){const i=this.properties;_t(i,n);const r=Object.keys(i),o=r.map(a=>n[a]);return await this.getPropertyValuesAtTexelAsync(r,e,t,s,o),r.forEach((a,l)=>n[a]=o[l]),n}getPropertyValuesAtTexelAsync(...e){this._asyncRead=!0;const t=this.getPropertyValuesAtTexel(...e);return this._asyncRead=!1,t}getPropertyValuesAtTexel(e,t,s,n,i=[]){for(;i.length<e.length;)i.push(null);i.length=e.length,ge.increaseSizeTo(i.length);const r=this.data,o=this.definition.properties,a=this.properties,l=Ei(n,t);for(let d=0,f=e.length;d<f;d++){const p=e[d];if(!o[p])continue;const m=a[p],g=r[m.index];Mi(n,m.texCoord,s,l,En),Ci(En,g.image.width,g.image.height,Mn),Cn.set(d,0),ge.renderPixelToTarget(g,Mn,Cn)}const h=new Uint8Array(e.length*4);if(this._asyncRead)return ge.readDataAsync(h).then(()=>(u.call(this),i));return ge.readData(h),u.call(this),i;function u(){for(let d=0,f=e.length;d<f;d++){const p=e[d],m=a[p],g=m.type;if(i[d]=Ts(m,i[d]),m){if(!o[p]){i[d]=m.resolveDefault(i);continue}}else throw new Error("PropertyTextureAccessor: Requested property does not exist.");const y=m.valueLength*(m.count||1),_=m.channels.map(E=>h[4*d+E]),A=m.componentType,x=et(A,g),T=new x(y);if(new Uint8Array(T.buffer).set(_),m.array){const E=i[d];for(let M=0,S=E.length;M<S;M++)E[M]=m.readDataFromBuffer(T,M,E[M])}else i[d]=m.readDataFromBuffer(T,0,i[d]);i[d]=m.adjustValueScaleOffset(i[d]),i[d]=m.resolveEnumsToStrings(i[d]),i[d]=m.resolveNoData(i[d])}}}dispose(){this.data.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}class Pn{constructor(e,t,s,n=null,i=null){const{schema:r,propertyTables:o=[],propertyTextures:a=[],propertyAttributes:l=[]}=e,{enums:h,classes:u}=r,d=o.map(m=>new ea(m,u,h,s));let f=[],p=[];n&&(n.propertyTextures&&(f=n.propertyTextures.map(m=>new aa(a[m],u,h,t))),n.propertyAttributes&&(p=n.propertyAttributes.map(m=>new Qo(l[m],u,h)))),this.schema=r,this.tableAccessors=d,this.textureAccessors=f,this.attributeAccessors=p,this.object=i,this.textures=t,this.nodeMetadata=n}getPropertyTableData(e,t,s=null){if(!Array.isArray(e)||!Array.isArray(t))s=s||{},s=this.tableAccessors[e].getData(t,s);else{s=s||[];const n=Math.min(e.length,t.length);s.length=n;for(let i=0;i<n;i++){const r=this.tableAccessors[e[i]];s[i]=r.getData(t[i],s[i])}}return s}getPropertyTableInfo(e=null){if(e===null&&(e=this.tableAccessors.map((t,s)=>s)),Array.isArray(e))return e.map(t=>{const s=this.tableAccessors[t];return{name:s.name,className:s.definition.class}});{const t=this.tableAccessors[e];return{name:t.name,className:t.definition.class}}}getPropertyTextureData(e,t,s=[]){const n=this.textureAccessors;s.length=n.length;for(let i=0;i<n.length;i++){const r=n[i];s[i]=r.getData(e,t,this.object.geometry,s[i])}return s}async getPropertyTextureDataAsync(e,t,s=[]){const n=this.textureAccessors;s.length=n.length;const i=[];for(let r=0;r<n.length;r++){const a=n[r].getDataAsync(e,t,this.object.geometry,s[r]).then(l=>{s[r]=l});i.push(a)}return await Promise.all(i),s}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(e,t=[]){const s=this.attributeAccessors;t.length=s.length;for(let n=0;n<s.length;n++){const i=s[n];t[n]=i.getData(e,this.object.geometry,t[n])}return t}getPropertyAttributeInfo(){return this.attributeAccessors.map(e=>({name:e.name,className:e.definition.class}))}dispose(){this.textureAccessors.forEach(e=>e.dispose()),this.tableAccessors.forEach(e=>e.dispose()),this.attributeAccessors.forEach(e=>e.dispose())}}const Xe="EXT_structural_metadata";function ca(c,e=[]){var n;const t=((n=c.json.textures)==null?void 0:n.length)||0,s=new Array(t).fill(null);return e.forEach(({properties:i})=>{for(const r in i){const{index:o}=i[r];s[o]===null&&(s[o]=c.loadTexture(o))}}),Promise.all(s)}function la(c,e=[]){var n;const t=((n=c.json.bufferViews)==null?void 0:n.length)||0,s=new Array(t).fill(null);return e.forEach(({properties:i})=>{for(const r in i){const{values:o,arrayOffsets:a,stringOffsets:l}=i[r];s[o]===null&&(s[o]=c.loadBufferView(o)),s[a]===null&&(s[a]=c.loadBufferView(a)),s[l]===null&&(s[l]=c.loadBufferView(l))}}),Promise.all(s)}class ha{constructor(e){this.parser=e,this.name=Xe}async afterRoot({scene:e,parser:t}){const s=t.json.extensionsUsed;if(!s||!s.includes(Xe))return;let n=null,i=t.json.extensions[Xe];if(i.schemaUri){const{manager:l,path:h,requestHeader:u,crossOrigin:d}=t.options,f=new URL(i.schemaUri,h).toString(),p=new Qe(l);p.setCrossOrigin(d),p.setResponseType("json"),p.setRequestHeader(u),n=p.loadAsync(f).then(m=>{i={...i,schema:m}})}const[r,o]=await Promise.all([ca(t,i.propertyTextures),la(t,i.propertyTables),n]),a=new Pn(i,r,o);e.userData.structuralMetadata=a,e.traverse(l=>{var h;if(t.associations.has(l)){const{meshes:u,primitives:d}=t.associations.get(l),f=(h=t.json.meshes[u])==null?void 0:h.primitives[d];if(f&&f.extensions&&f.extensions[Xe]){const p=f.extensions[Xe];l.userData.structuralMetadata=new Pn(i,r,o,p,l)}else l.userData.structuralMetadata=a}})}}const Rn=new I,vn=new I,Ln=new I;function ua(c){return c.x>c.y&&c.x>c.z?0:c.y>c.z?1:2}class da{constructor(e,t,s){this.geometry=e,this.textures=t,this.data=s,this._asyncRead=!1,this.featureIds=s.featureIds.map(n=>{const{texture:i,...r}=n,o={label:null,propertyTable:null,nullFeatureId:null,...r};return i&&(o.texture={texCoord:0,channels:[0],...i}),o})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...e){this._asyncRead=!0;const t=this.getFeatures(...e);return this._asyncRead=!1,t}getFeatures(e,t){const{geometry:s,textures:n,featureIds:i}=this,r=new Array(i.length).fill(null),o=i.length;ge.increaseSizeTo(o);const a=Ei(s,e),l=a[ua(t)];for(let d=0,f=i.length;d<f;d++){const p=i[d],m="nullFeatureId"in p?p.nullFeatureId:null;if("texture"in p){const g=n[p.texture.index];Mi(s,p.texture.texCoord,t,a,Rn),Ci(Rn,g.image.width,g.image.height,vn),Ln.set(d,0),ge.renderPixelToTarget(n[p.texture.index],vn,Ln)}else if("attribute"in p){const y=s.getAttribute(`_feature_id_${p.attribute}`).getX(l);y!==m&&(r[d]=y)}else{const g=l;g!==m&&(r[d]=g)}}const h=new Uint8Array(o*4);if(this._asyncRead)return ge.readDataAsync(h).then(()=>(u(),r));return ge.readData(h),u(),r;function u(){const d=new Uint32Array(1);for(let f=0,p=i.length;f<p;f++){const m=i[f],g="nullFeatureId"in m?m.nullFeatureId:null;if("texture"in m){const{channels:y}=m.texture,_=y.map(x=>h[4*f+x]);new Uint8Array(d.buffer).set(_);const A=d[0];A!==g&&(r[f]=A)}}}}dispose(){this.textures.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}const Tt="EXT_mesh_features";function In(c,e,t){c.traverse(s=>{var n;if(e.associations.has(s)){const{meshes:i,primitives:r}=e.associations.get(s),o=(n=e.json.meshes[i])==null?void 0:n.primitives[r];o&&o.extensions&&o.extensions[Tt]&&t(s,o.extensions[Tt])}})}class fa{constructor(e){this.parser=e,this.name=Tt}async afterRoot({scene:e,parser:t}){var o;const s=t.json.extensionsUsed;if(!s||!s.includes(Tt))return;const n=((o=t.json.textures)==null?void 0:o.length)||0,i=new Array(n).fill(null);In(e,t,(a,{featureIds:l})=>{l.forEach(h=>{if(h.texture&&i[h.texture.index]===null){const u=h.texture.index;i[u]=t.loadTexture(u)}})});const r=await Promise.all(i);In(e,t,(a,l)=>{a.userData.meshFeatures=new da(a.geometry,r,l)})}}class pa{constructor(){this.name="CESIUM_RTC"}afterRoot(e){if(e.parser.json.extensions&&e.parser.json.extensions.CESIUM_RTC){const{center:t}=e.parser.json.extensions.CESIUM_RTC;t&&(e.scene.position.x+=t[0],e.scene.position.y+=t[1],e.scene.position.z+=t[2])}}}class ma{constructor(e){e={metadata:!0,rtc:!0,plugins:[],dracoLoader:null,ktxLoader:null,meshoptDecoder:null,autoDispose:!0,...e},this.tiles=null,this.metadata=e.metadata,this.rtc=e.rtc,this.plugins=e.plugins,this.dracoLoader=e.dracoLoader,this.ktxLoader=e.ktxLoader,this.meshoptDecoder=e.meshoptDecoder,this._gltfRegex=/\.(gltf|glb)$/g,this._dracoRegex=/\.drc$/g,this._loader=null}init(e){const t=new St(e.manager);this.dracoLoader&&(t.setDRACOLoader(this.dracoLoader),e.manager.addHandler(this._dracoRegex,this.dracoLoader)),this.ktxLoader&&t.setKTX2Loader(this.ktxLoader),this.meshoptDecoder&&t.setMeshoptDecoder(this.meshoptDecoder),this.rtc&&t.register(()=>new pa),this.metadata&&(t.register(()=>new ha),t.register(()=>new fa)),this.plugins.forEach(s=>t.register(s)),e.manager.addHandler(this._gltfRegex,t),this.tiles=e,this._loader=t}dispose(){this.tiles.manager.removeHandler(this._gltfRegex),this.tiles.manager.removeHandler(this._dracoRegex),this.autoDispose&&(this.ktxLoader.dispose(),this.dracoLoader.dispose())}}class ga{set delay(e){this.deferCallbacks.delay=e}get delay(){return this.deferCallbacks.delay}set bytesTarget(e){this.lruCache.minBytesSize=e}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(e={}){const{delay:t=0,bytesTarget:s=0}=e;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new ei,this.deferCallbacks=new ya,this.delay=t,this.bytesTarget=s}init(e){this.tiles=e;const{lruCache:t,deferCallbacks:s}=this;s.callback=i=>{t.markUnused(i),t.scheduleUnload(!1)};const n=i=>{const r=i.cached.scene;e.visibleTiles.has(i)||e.invokeOnePlugin(a=>a.unloadTileFromGPU&&a.unloadTileFromGPU(r,i))};this._onUpdateBefore=()=>{t.unloadPriorityCallback=e.lruCache.unloadPriorityCallback,t.computeMemoryUsageCallback=e.lruCache.computeMemoryUsageCallback,t.minSize=1/0,t.maxSize=1/0,t.maxBytesSize=1/0,t.unloadPercent=1,t.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:i,visible:r})=>{r?(t.add(i,n),e.markTileUsed(i),s.cancel(i)):s.run(i)},e.forEachLoadedModel((i,r)=>{const o=e.visibleTiles.has(r);this._onVisibilityChangeCallback({scene:i,visible:o})}),e.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),e.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(e,t){e&&e.traverse(s=>{if(s.material){const n=s.material;n.dispose();for(const i in n){const r=n[i];r&&r.isTexture&&r.dispose()}}s.geometry&&s.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class ya{constructor(e=()=>{}){this.map=new Map,this.callback=e,this.delay=0}run(e){const{map:t,delay:s}=this;if(t.has(e))throw new Error("DeferCallbackManager: Callback already initialized.");s===0?this.callback(e):t.set(e,setTimeout(()=>this.callback(e),s))}cancel(e){const{map:t}=this;t.has(e)&&(clearTimeout(t.get(e)),t.delete(e))}cancelAll(){this.map.forEach((e,t)=>{this.cancel(t)})}}const{clamp:ss}=v;class _a{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(e){e&&this.completeFade(e)}guaranteeState(e){const t=this._fadeState;if(t.has(e))return!1;const s={fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0};return t.set(e,s),!0}completeFade(e){const t=this._fadeState;if(!t.has(e))return;const s=t.get(e).fadeOutTarget===0;t.delete(e),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(e,s),this.fadeCount===0&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach((e,t)=>{this.completeFade(t)})}forEachObject(e){this._fadeState.forEach((t,s)=>{e(s,t)})}fadeIn(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeInTarget=1,s.fadeOutTarget=0,s.fadeOut=0,t&&(this.fadeCount++,this.fadeCount===1&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}fadeOut(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeOutTarget=1,t&&(s.fadeInTarget=1,s.fadeIn=1,this.fadeCount++,this.fadeCount===1&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}isFading(e){return this._fadeState.has(e)}isFadingOut(e){const t=this._fadeState.get(e);return t&&t.fadeOutTarget===1}update(){const e=window.performance.now();this._lastTick===-1&&(this._lastTick=e);const t=ss((e-this._lastTick)/this.duration,0,1);this._lastTick=e,this._fadeState.forEach((n,i)=>{const{fadeOutTarget:r,fadeInTarget:o}=n;let{fadeOut:a,fadeIn:l}=n;const h=Math.sign(o-l);l=ss(l+h*t,0,1);const u=Math.sign(r-a);a=ss(a+u*t,0,1),n.fadeIn=l,n.fadeOut=a,((a===1||a===0)&&(l===1||l===0)||a>=l)&&this.completeFade(i)})}}function Pi(c,e){const t={fadeIn:{value:0},fadeOut:{value:0},fadeTexture:{value:null}};return c.defines={...c.defines||{},FEATURE_FADE:0},c.onBeforeCompile=s=>{e&&e(s),s.uniforms={...s.uniforms,...t},s.vertexShader=s.vertexShader.replace(/void\s+main\(\)\s+{/,n=>`
					#ifdef USE_BATCHING_FRAG

					varying float vBatchId;

					#endif

					${n}

						#ifdef USE_BATCHING_FRAG

						// add 0.5 to the value to avoid floating error that may cause flickering
						vBatchId = getIndirectIndex( gl_DrawID ) + 0.5;

						#endif
				`),s.fragmentShader=s.fragmentShader.replace(/void main\(/,n=>`
				#if FEATURE_FADE

				// adapted from https://www.shadertoy.com/view/Mlt3z8
				float bayerDither2x2( vec2 v ) {

					return mod( 3.0 * v.y + 2.0 * v.x, 4.0 );

				}

				float bayerDither4x4( vec2 v ) {

					vec2 P1 = mod( v, 2.0 );
					vec2 P2 = floor( 0.5 * mod( v, 4.0 ) );
					return 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );

				}

				// the USE_BATCHING define is not available in fragment shaders
				#ifdef USE_BATCHING_FRAG

				// functions for reading the fade state of a given batch id
				uniform sampler2D fadeTexture;
				varying float vBatchId;
				vec2 getFadeValues( const in float i ) {

					int size = textureSize( fadeTexture, 0 ).x;
					int j = int( i );
					int x = j % size;
					int y = j / size;
					return texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;

				}

				#else

				uniform float fadeIn;
				uniform float fadeOut;

				#endif

				#endif

				${n}
			`).replace(/#include <dithering_fragment>/,n=>`

				${n}

				#if FEATURE_FADE

				#ifdef USE_BATCHING_FRAG

				vec2 fadeValues = getFadeValues( vBatchId );
				float fadeIn = fadeValues.r;
				float fadeOut = fadeValues.g;

				#endif

				float bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );
				float bayerBins = 16.0;
				float dither = ( 0.5 + bayerValue ) / bayerBins;
				if ( dither >= fadeIn ) {

					discard;

				}

				if ( dither < fadeOut ) {

					discard;

				}

				#endif

			`)},t}class Ta{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(e,t,s){if(!e)return;const n=this._fadeParams;e.traverse(i=>{const r=i.material;if(r){const o=n.get(r);o.fadeIn.value=t,o.fadeOut.value=s;const h=+(!(t===0||t===1)||!(s===0||s===1));r.defines.FEATURE_FADE!==h&&(this.fading+=h===1?1:-1,r.defines.FEATURE_FADE=h,r.needsUpdate=!0)}})}prepareScene(e){e.traverse(t=>{t.material&&this.prepareMaterial(t.material)})}deleteScene(e){if(!e)return;const t=this._fadeParams;e.traverse(s=>{const n=s.material;n&&(t.delete(n),n.onBeforeCompile=()=>{},n.needsUpdate=!0)})}prepareMaterial(e){const t=this._fadeParams;t.has(e)||t.set(e,Pi(e))}}class ba{constructor(e,t=new Le){this.other=e,this.material=t,this.visible=!0,this.parent=null,this._instanceInfo=[],this._visibilityChanged=!0;const s=new Proxy(this,{get(n,i){if(i in n)return n[i];{const r=e[i];return r instanceof Function?(...o)=>(n.syncInstances(),r.call(s,...o)):e[i]}},set(n,i,r){return i in n?n[i]=r:e[i]=r,!0},deleteProperty(n,i){return i in n?delete n[i]:delete e[i]}});return s}syncInstances(){const e=this._instanceInfo,t=this.other._instanceInfo;for(;t.length>e.length;){const s=e.length;e.push(new Proxy({visible:!1},{get(n,i){return i in n?n[i]:t[s][i]},set(n,i,r){return i in n?n[i]=r:t[s][i]=r,!0}}))}}}class xa extends ba{constructor(...e){super(...e);const t=this.material,s=Pi(t,t.onBeforeCompile);t.defines.FEATURE_FADE=1,t.defines.USE_BATCHING_FRAG=1,t.needsUpdate=!0,this.fadeTexture=null,this._fadeParams=s}setFadeAt(e,t,s){this._initFadeTexture(),this.fadeTexture.setValueAt(e,t*255,s*255)}_initFadeTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=e*e*2,s=this.fadeTexture;if(!s||s.image.data.length!==t){const n=new Uint8Array(t),i=new Aa(n,e,e,_r,Tr);if(s){s.dispose();const r=s.image.data,o=this.fadeTexture.image.data,a=Math.min(r.length,o.length);o.set(new r.constructor(r.buffer,0,a))}this.fadeTexture=i,this._fadeParams.fadeTexture.value=i,i.needsUpdate=!0}}dispose(){this.fadeTexture&&this.fadeTexture.dispose()}}class Aa extends br{setValueAt(e,...t){const{data:s,width:n,height:i}=this.image,r=Math.floor(s.length/(n*i));let o=!1;for(let a=0;a<r;a++){const l=e*r+a,h=s[l],u=t[a]||0;h!==u&&(s[l]=u,o=!0)}o&&(this.needsUpdate=!0)}}const Dn=Symbol("HAS_POPPED_IN"),Fn=new b,On=new b,Nn=new ee,kn=new ee,Un=new b;function wa(){const c=this._fadeManager,e=this.tiles;this._fadingBefore=c.fadeCount,this._displayActiveTiles=e.displayActiveTiles,e.displayActiveTiles=!0}function Sa(){const c=this._fadeManager,e=this._fadeMaterialManager,t=this._displayActiveTiles,s=this._fadingBefore,n=this._prevCameraTransforms,{tiles:i,maximumFadeOutTiles:r,batchedMesh:o}=this,{cameras:a}=i;i.displayActiveTiles=t,c.update();const l=c.fadeCount;if(s!==0&&l!==0&&(i.dispatchEvent({type:"fade-change"}),i.dispatchEvent({type:"force-rerender"})),t||i.visibleTiles.forEach(h=>{const u=h.cached.scene;u&&(u.visible=h.__inFrustum),this.forEachBatchIds(h,(d,f,p)=>{f.setVisibleAt(d,h.__inFrustum),p.batchedMesh.setVisibleAt(d,h.__inFrustum)})}),r<this._fadingOutCount){let h=!0;a.forEach(u=>{if(!n.has(u))return;const d=u.matrixWorld,f=n.get(u);d.decompose(On,kn,Un),f.decompose(Fn,Nn,Un);const p=kn.angleTo(Nn),m=On.distanceTo(Fn);h=h&&(p>.25||m>.1)}),h&&c.completeAllFades()}if(a.forEach(h=>{n.get(h).copy(h.matrixWorld)}),c.forEachObject((h,{fadeIn:u,fadeOut:d})=>{const f=h.cached.scene,p=c.isFadingOut(h);i.markTileUsed(h),f&&(e.setFade(f,u,d),p&&(f.visible=!0)),this.forEachBatchIds(h,(m,g,y)=>{g.setFadeAt(m,u,d),g.setVisibleAt(m,!0),y.batchedMesh.setVisibleAt(m,!1)})}),o){const h=i.getPluginByName("BATCHED_TILES_PLUGIN").batchedMesh.material;o.material.map=h.map}}class Ea{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(e){this._fadeManager.duration=Number(e)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(e){e={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...e},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._fadeManager=new _a,this._fadeMaterialManager=new Ta,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=e.maximumFadeOutTiles,this.fadeRootTiles=e.fadeRootTiles,this.fadeDuration=e.fadeDuration}init(e){this._onLoadModel=({scene:n})=>{this._fadeMaterialManager.prepareScene(n)},this._onDisposeModel=({tile:n,scene:i})=>{this._fadeManager.deleteObject(n),this._fadeMaterialManager.deleteScene(i)},this._onAddCamera=({camera:n})=>{this._prevCameraTransforms.set(n,new L)},this._onDeleteCamera=({camera:n})=>{this._prevCameraTransforms.delete(n)},this._onTileVisibilityChange=({tile:n,visible:i})=>{const r=n.cached.scene;r&&(r.visible=!0),this.forEachBatchIds(n,(o,a,l)=>{a.setFadeAt(o,0,0),a.setVisibleAt(o,!1),l.batchedMesh.setVisibleAt(o,!1)})},this._onUpdateBefore=()=>{wa.call(this)},this._onUpdateAfter=()=>{Sa.call(this)},e.addEventListener("load-model",this._onLoadModel),e.addEventListener("dispose-model",this._onDisposeModel),e.addEventListener("add-camera",this._onAddCamera),e.addEventListener("delete-camera",this._onDeleteCamera),e.addEventListener("update-before",this._onUpdateBefore),e.addEventListener("update-after",this._onUpdateAfter),e.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const t=this._fadeManager;t.onFadeSetStart=()=>{e.dispatchEvent({type:"fade-start"}),e.dispatchEvent({type:"force-rerender"})},t.onFadeSetComplete=()=>{e.dispatchEvent({type:"fade-end"}),e.dispatchEvent({type:"force-rerender"})},t.onFadeComplete=(n,i)=>{this._fadeMaterialManager.setFade(n.cached.scene,0,0),this.forEachBatchIds(n,(r,o,a)=>{o.setFadeAt(r,0,0),o.setVisibleAt(r,!1),a.batchedMesh.setVisibleAt(r,i)}),i||(e.invokeOnePlugin(r=>r!==this&&r.setTileVisible&&r.setTileVisible(n,!1)),this._fadingOutCount--)};const s=new Map;e.cameras.forEach(n=>{s.set(n,new L)}),e.forEachLoadedModel((n,i)=>{this._onLoadModel({scene:n})}),this.tiles=e,this._fadeManager=t,this._prevCameraTransforms=s}initBatchedMesh(){var t;const e=(t=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"))==null?void 0:t.batchedMesh;if(e){if(this.batchedMesh===null){this._onBatchedMeshDispose=()=>{this.batchedMesh.dispose(),this.batchedMesh.removeFromParent(),this.batchedMesh=null,e.removeEventListener("dispose",this._onBatchedMeshDispose)};const s=e.material.clone();s.onBeforeCompile=e.material.onBeforeCompile,this.batchedMesh=new xa(e,s),this.tiles.group.add(this.batchedMesh)}}else this.batchedMesh!==null&&(this._onBatchedMeshDispose(),this._onBatchedMeshDispose=null)}setTileVisible(e,t){const s=this._fadeManager,n=s.isFading(e);if(s.isFadingOut(e)&&this._fadingOutCount--,t?e.__depthFromRenderedParent===1?((e[Dn]||this.fadeRootTiles)&&this._fadeManager.fadeIn(e),e[Dn]=!0):this._fadeManager.fadeIn(e):(this._fadingOutCount++,s.fadeOut(e)),n)return!0;const i=this._fadeManager.isFading(e);return!!(!t&&i)}dispose(){const e=this.tiles;this._fadeManager.completeAllFades(),this.batchedMesh!==null&&this._onBatchedMeshDispose(),e.removeEventListener("load-model",this._onLoadModel),e.removeEventListener("dispose-model",this._onDisposeModel),e.removeEventListener("add-camera",this._onAddCamera),e.removeEventListener("delete-camera",this._onDeleteCamera),e.removeEventListener("update-before",this._onUpdateBefore),e.removeEventListener("update-after",this._onUpdateAfter),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),e.forEachLoadedModel((t,s)=>{this._fadeManager.deleteObject(s),t&&(t.visible=!0)})}forEachBatchIds(e,t){if(this.initBatchedMesh(),this.batchedMesh){const s=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"),n=s.getTileBatchIds(e);n&&n.forEach(i=>{t(i,this.batchedMesh,s)})}}}const ns=new WeakMap;class Ma extends Vn{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,s,n){const i=new Qe(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,r=>{this.parse(r,t,n)},s,n)}parse(e,t,s=()=>{}){this.decodeDracoFile(e,t,null,null,ye,s).catch(s)}decodeDracoFile(e,t,s,n,i=Q,r=()=>{}){const o={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:i};return this.decodeGeometry(e,o).then(t).catch(r)}decodeGeometry(e,t){const s=JSON.stringify(t);if(ns.has(e)){const a=ns.get(e);if(a.key===s)return a.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const i=this.workerNextTaskID++,r=e.byteLength,o=this._getWorker(i,r).then(a=>(n=a,new Promise((l,h)=>{n._callbacks[i]={resolve:l,reject:h},n.postMessage({type:"decode",id:i,taskConfig:t,buffer:e},[e])}))).then(a=>this._createGeometry(a.geometry));return o.catch(()=>!0).then(()=>{n&&i&&this._releaseTask(n,i)}),ns.set(e,{key:s,promise:o}),o}_createGeometry(e){const t=new bt;e.index&&t.setIndex(new z(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const n=e.attributes[s],i=n.name,r=n.array,o=n.itemSize,a=new z(r,o);i==="color"&&(this._assignVertexColorSpace(a,n.vertexColorSpace),a.normalized=!(r instanceof Float32Array)),t.setAttribute(i,a)}return t}_assignVertexColorSpace(e,t){if(t!==ye)return;const s=new ce;for(let n=0,i=e.count;n<i;n++)s.fromBufferAttribute(e,n),os.toWorkingColorSpace(s,ye),e.setXYZ(n,s.r,s.g,s.b)}_loadLibrary(e,t){const s=new Qe(this.manager);return s.setPath(this.decoderPath),s.setResponseType(t),s.setWithCredentials(this.withCredentials),new Promise((n,i)=>{s.load(e,n,void 0,i)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(s=>{const n=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const i=Ca.toString(),r=["/* draco decoder */",n,"","/* worker */",i.substring(i.indexOf("{")+1,i.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(i){const r=i.data;switch(r.type){case"decode":n._callbacks[r.id].resolve(r);break;case"error":n._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(n,i){return n._taskLoad>i._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=t,s._taskLoad+=t,s})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Ca(){let c,e;onmessage=function(r){const o=r.data;switch(o.type){case"init":c=o.decoderConfig,e=new Promise(function(h){c.onModuleLoaded=function(u){h({draco:u})},DracoDecoderModule(c)});break;case"decode":const a=o.buffer,l=o.taskConfig;e.then(h=>{const u=h.draco,d=new u.Decoder;try{const f=t(u,d,new Int8Array(a),l),p=f.attributes.map(m=>m.array.buffer);f.index&&p.push(f.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:f},p)}catch(f){console.error(f),self.postMessage({type:"error",id:o.id,error:f.message})}finally{u.destroy(d)}});break}};function t(r,o,a,l){const h=l.attributeIDs,u=l.attributeTypes;let d,f;const p=o.GetEncodedGeometryType(a);if(p===r.TRIANGULAR_MESH)d=new r.Mesh,f=o.DecodeArrayToMesh(a,a.byteLength,d);else if(p===r.POINT_CLOUD)d=new r.PointCloud,f=o.DecodeArrayToPointCloud(a,a.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!f.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+f.error_msg());const m={index:null,attributes:[]};for(const g in h){const y=self[u[g]];let _,A;if(l.useUniqueIDs)A=h[g],_=o.GetAttributeByUniqueId(d,A);else{if(A=o.GetAttributeId(d,r[h[g]]),A===-1)continue;_=o.GetAttribute(d,A)}const x=n(r,o,d,g,y,_);g==="color"&&(x.vertexColorSpace=l.vertexColorSpace),m.attributes.push(x)}return p===r.TRIANGULAR_MESH&&(m.index=s(r,o,d)),r.destroy(d),m}function s(r,o,a){const h=a.num_faces()*3,u=h*4,d=r._malloc(u);o.GetTrianglesUInt32Array(a,u,d);const f=new Uint32Array(r.HEAPF32.buffer,d,h).slice();return r._free(d),{array:f,itemSize:1}}function n(r,o,a,l,h,u){const d=u.num_components(),p=a.num_points()*d,m=p*h.BYTES_PER_ELEMENT,g=i(r,h),y=r._malloc(m);o.GetAttributeDataArrayForAllPoints(a,u,g,m,y);const _=new h(r.HEAPF32.buffer,y,p).slice();return r._free(y),{name:l,array:_,itemSize:d}}function i(r,o){switch(o){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}class Ra{constructor(e,t,s){this.scene=e,this.camera=t,this.renderer=s,this.tiles=new Lo,this.tiles.registerPlugin(new zo({apiToken:"AIzaSyAV5oMvL_l7V0H6jELHb5OCYGjLDWozW8g",autoRefreshToken:!0})),this.tiles.registerPlugin(new jo),this.tiles.registerPlugin(new Go),this.tiles.registerPlugin(new ga),this.tiles.registerPlugin(new Ea),this.tiles.registerPlugin(new ma({dracoLoader:new Ma().setDecoderPath("https://www.gstatic.com/draco/v1/decoders/")})),this.tiles.setResolutionFromRenderer(this.camera,this.renderer),this.tiles.setCamera(this.camera),this.controls=new Bo(this.scene,this.camera,this.renderer.domElement,this.tiles),this.controls.enableDamping=!0}update(){this.controls.enabled=!0,this.controls.update(),this.camera.updateMatrixWorld(),this.tiles.setResolutionFromRenderer(this.camera,this.renderer),this.tiles.setCamera(this.camera),this.tiles.update()}}export{Ra as G};
